File: ./GrammarModel.scala
package com.beepboop.app

import com.beepboop.app.{GrammarSymbol, ProductionAlternative, ProductionRule}

sealed trait GrammarSymbol {
  def name: String
}

case class NonTerminal(override val name: String) extends GrammarSymbol {
  override def toString: String = s"<$name>"
}

case class Terminal(override val name: String, value: String) extends GrammarSymbol {
  override def toString: String = if (name == value || name.startsWith("'")) s"'$value'" else name
}

case class VarPlaceholder(override val name: String) extends GrammarSymbol {
  override def toString: String = s"VAR_PLACEHOLDER[${name}]"
}

case class Optional(symbol: GrammarSymbol, isGreedy: Boolean = true) extends GrammarSymbol {
  override def name: String = s"${symbol.name}?"
  override def toString: String = s"(${symbol.toString})?"
}

case class ZeroOrMore(symbol: GrammarSymbol, isGreedy: Boolean = true) extends GrammarSymbol {
  override def name: String = s"${symbol.name}*"
  override def toString: String = s"(${symbol.toString})*"
}

case class OneOrMore(symbol: GrammarSymbol, isGreedy: Boolean = true) extends GrammarSymbol {
  override def name: String = s"${symbol.name}+"
  override def toString: String = s"(${symbol.toString})+"
}


case class ProductionAlternative(symbols: List[GrammarSymbol]) {
  override def toString: String = symbols.mkString(" ")
}


case class ProductionRule(
                           ruleName: String,
                           alternatives: List[ProductionAlternative]
                         ) {
  override def toString: String = s"$ruleName ::= ${alternatives.map(_.toString).mkString(" | ")}"
}

case class ParsedGrammar(
                          grammarName: String,
                          startSymbol: Option[String],
                          rules: Map[String, ProductionRule],
                          tokens: Map[String, String]
                        ) {
  override def toString: String = {
    s"""
       |Grammar: $grammarName
       |Start Symbol: ${startSymbol.getOrElse("Not explicitly defined, assuming first rule")}
       |Tokens:
       |${tokens.map{case (k,v) => s"  $k : '$v'"}.mkString("\n")}
       |Rules:
       |${rules.values.map("  " + _.toString).mkString("\n")}
    """.stripMargin
  }
}

---

File: ./LexerAdaptor.java
/*
 [The "BSD licence"]
 Copyright (c) 2005-2007 Terence Parr
 All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions
 are met:
 1. Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.
 2. Redistributions in binary form must reproduce the above copyright
    notice, this list of conditions and the following disclaimer in the
    documentation and/or other materials provided with the distribution.
 3. The name of the author may not be used to endorse or promote products
    derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
package com.beepboop.parser;


import org.antlr.v4.runtime.CharStream;
import org.antlr.v4.runtime.Lexer;
import org.antlr.v4.runtime.Token;
import org.antlr.v4.runtime.misc.Interval;

public abstract class LexerAdaptor extends Lexer {

    /**
     *  Generic type for OPTIONS, TOKENS and CHANNELS
     */
    private static final int PREQUEL_CONSTRUCT = -10;
    private static final int OPTIONS_CONSTRUCT = -11;

    public LexerAdaptor(CharStream input) {
        super(input);
    }

    /**
     * Track whether we are inside of a rule and whether it is lexical parser. _currentRuleType==Token.INVALID_TYPE
     * means that we are outside of a rule. At the first sign of a rule name reference and _currentRuleType==invalid, we
     * can assume that we are starting a parser rule. Similarly, seeing a token reference when not already in rule means
     * starting a token rule. The terminating ';' of a rule, flips this back to invalid type.
     *
     * This is not perfect logic but works. For example, "grammar T;" means that we start and stop a lexical rule for
     * the "T;". Dangerous but works.
     *
     * The whole point of this state information is to distinguish between [..arg actions..] and [charsets]. Char sets
     * can only occur in lexical rules and arg actions cannot occur.
     */
    private int _currentRuleType = Token.INVALID_TYPE;

    public int getCurrentRuleType() {
        return _currentRuleType;
    }

    public void setCurrentRuleType(int ruleType) {
        this._currentRuleType = ruleType;
    }

    protected void handleBeginArgument() {
        if (inLexerRule()) {
            pushMode(ANTLRv4Lexer.LexerCharSet);
            more();
        } else {
            pushMode(ANTLRv4Lexer.Argument);
        }
    }

    protected void handleEndArgument() {
        popMode();
        if (_modeStack.size() > 0) {
            setType(ANTLRv4Lexer.ARGUMENT_CONTENT);
        }
    }

    @Override
    public Token emit() {
        if ((_type == ANTLRv4Lexer.OPTIONS || _type == ANTLRv4Lexer.TOKENS || _type == ANTLRv4Lexer.CHANNELS)
                && getCurrentRuleType() == Token.INVALID_TYPE) { // enter prequel construct ending with an RBRACE
            setCurrentRuleType(PREQUEL_CONSTRUCT);
        } else if (_type == ANTLRv4Lexer.OPTIONS && getCurrentRuleType() == ANTLRv4Lexer.TOKEN_REF)
        {
            setCurrentRuleType(OPTIONS_CONSTRUCT);
        } else if (_type == ANTLRv4Lexer.RBRACE && getCurrentRuleType() == PREQUEL_CONSTRUCT) { // exit prequel construct
            setCurrentRuleType(Token.INVALID_TYPE);
        } else if (_type == ANTLRv4Lexer.RBRACE && getCurrentRuleType() == OPTIONS_CONSTRUCT)
        { // exit options
            setCurrentRuleType(ANTLRv4Lexer.TOKEN_REF);
        } else if (_type == ANTLRv4Lexer.AT && getCurrentRuleType() == Token.INVALID_TYPE) { // enter action
            setCurrentRuleType(ANTLRv4Lexer.AT);
        } else if (_type == ANTLRv4Lexer.SEMI && getCurrentRuleType() == OPTIONS_CONSTRUCT)
        { // ';' in options { .... }. Don't change anything.
        } else if (_type == ANTLRv4Lexer.ACTION && getCurrentRuleType() == ANTLRv4Lexer.AT) { // exit action
            setCurrentRuleType(Token.INVALID_TYPE);
        } else if (_type == ANTLRv4Lexer.ID) {
            String firstChar = _input.getText(Interval.of(_tokenStartCharIndex, _tokenStartCharIndex));
            if (Character.isUpperCase(firstChar.charAt(0))) {
                _type = ANTLRv4Lexer.TOKEN_REF;
            } else {
                _type = ANTLRv4Lexer.RULE_REF;
            }

            if (getCurrentRuleType() == Token.INVALID_TYPE) { // if outside of rule def
                setCurrentRuleType(_type); // set to inside lexer or parser rule
            }
        } else if (_type == ANTLRv4Lexer.SEMI) { // exit rule def
            setCurrentRuleType(Token.INVALID_TYPE);
        }

        return super.emit();
    }

    private boolean inLexerRule() {
        return getCurrentRuleType() == ANTLRv4Lexer.TOKEN_REF;
    }

    @SuppressWarnings("unused")
    private boolean inParserRule() { // not used, but added for clarity
        return getCurrentRuleType() == ANTLRv4Lexer.RULE_REF;
    }

    @Override
    public void reset() {
        setCurrentRuleType(Token.INVALID_TYPE);
        super.reset();
    }
}

---

File: ./ParserUtil.scala
package com.beepboop.app

import com.beepboop.app.logger.LogTrait
import org.antlr.v4.runtime.{CharStream, CharStreams, CommonTokenStream, Lexer, Parser, TokenStream}
import org.antlr.v4.runtime.tree.ParseTree
import com.typesafe.scalalogging.*



object ParserUtil extends LogTrait {

  def parseCode[L <: Lexer, P <: Parser](
                                          code: String,
                                          lexerFactory: (CharStream) => L,
                                          parserFactory: (TokenStream) => P,
                                          startRuleInvoker: (P) => ParseTree
                                        ): (P, ParseTree) = { 

    val input: CharStream = CharStreams.fromString(code)

    val lexer: L = lexerFactory(input)

    val tokens: CommonTokenStream = new CommonTokenStream(lexer)

    val parser: P = parserFactory(tokens)

    val tree: ParseTree = startRuleInvoker(parser)

    debug("--- Parse tree (LISP style) ---")
    debug(tree.toStringTree(parser))

    (parser, tree)
  }
}

---

File: ./GrammarConverter.scala
package com.beepboop.app

import com.beepboop.app.logger.LogTrait
import com.beepboop.app.{G4ToInternalRepresentationListener, MinizincModelListener, ParserUtil}
import com.beepboop.parser.*
import com.typesafe.scalalogging.*
import org.antlr.v4.runtime.tree.ParseTreeWalker
import org.antlr.v4.runtime.{CharStream, CharStreams, CommonTokenStream, TokenStream}

import java.nio.file.{Files, Paths}
import scala.io.Source

object GrammarConverter extends LogTrait {

  def parseConstraintGrammar(): ParsedGrammar = {
    val grammarString = scala.io.Source.fromFile("src/main/antlr4/com/beepboop/parser/ModelConstraintGrammar.g4").mkString
    val (metaParser, g4ParseTree) = ParserUtil.parseCode(
      code = grammarString,
      lexerFactory = (cs: CharStream) => new ANTLRv4Lexer(cs),
      parserFactory = (ts: TokenStream) => new ANTLRv4Parser(ts),
      startRuleInvoker = (p: ANTLRv4Parser) => p.grammarSpec()
    )

    info("\nParsing g4 grammar to internal representation")

    val listener = new G4ToInternalRepresentationListener(specialVarSymbolName = "var_symbol_placeholder")
    val walker = new ParseTreeWalker()
    walker.walk(listener, g4ParseTree)

    val internalGrammar: ParsedGrammar = listener.getParsedGrammar
    internalGrammar
  }

}




---

File: ./G4ToInternalRepresentationListener.scala
package com.beepboop.app

import com.beepboop.app.astar.*
import com.beepboop.app.logger.LogTrait
import com.beepboop.parser.ANTLRv4Parser.*
import com.beepboop.parser.ANTLRv4ParserBaseListener
import org.antlr.v4.runtime.tree.TerminalNode

import scala.collection.mutable
import scala.jdk.CollectionConverters.*

class G4ToInternalRepresentationListener(val specialVarSymbolName: String = "var_symbol_placeholder") extends ANTLRv4ParserBaseListener, LogTrait {

  private var grammarName: String = "UnknownGrammar"
  private val rules = mutable.Map[String, ProductionRule]()
  private val tokenLiterals = mutable.Map[String, String]()
  private val declaredTokenNames = mutable.Set[String]()

  private var currentRuleName: Option[String] = None
  private var currentAlternatives: mutable.ListBuffer[ProductionAlternative] = mutable.ListBuffer()
  private var currentSymbolsInAlternative: mutable.ListBuffer[GrammarSymbol] = mutable.ListBuffer()
  private var firstParserRuleName: Option[String] = None

  def getParsedGrammar: ParsedGrammar = {
    val finalTokensMap = declaredTokenNames.map { tokenName =>
      tokenName -> tokenLiterals.getOrElse(tokenName, s"[$tokenName Pattern]")
    }.toMap
    ParsedGrammar(grammarName, firstParserRuleName, rules.toMap, finalTokensMap)
  }

  private def stripQuotes(text: String): String = {
    if (text == null) return ""
    if (text.length >= 2) {
      if (text.startsWith("'") && text.endsWith("'")) {
        text.substring(1, text.length - 1)
      } else if (text.startsWith("\"") && text.endsWith("\"")) {
        text.substring(1, text.length - 1)
      } else text
    } else text
  }

  override def enterGrammarSpec(ctx: GrammarSpecContext): Unit = {
    if (ctx.grammarDecl() != null && ctx.grammarDecl().identifier() != null) {
      val idCtx = ctx.grammarDecl().identifier()
      if (idCtx.RULE_REF() != null) grammarName = idCtx.RULE_REF().getText
      else if (idCtx.TOKEN_REF() != null) grammarName = idCtx.TOKEN_REF().getText
      else grammarName = "GrammarNameError"
      warn(s"DEBUG [enterGrammarSpec]: Grammar name set to '$grammarName'")
    } else {
      warn("WARNING [enterGrammarSpec]: Could not determine grammar name from grammarDecl.")
    }
  }

  override def enterTokensSpec(ctx: TokensSpecContext): Unit = {
    if (ctx.idList() != null) {
      ctx.idList().identifier().asScala.foreach { idCtx =>
        val tokenName = if (idCtx.TOKEN_REF() != null) idCtx.TOKEN_REF().getText
        else if (idCtx.RULE_REF() != null) idCtx.RULE_REF().getText
        else "UNKNOWN_TOKEN_IN_TOKENS_BLOCK"
        declaredTokenNames += tokenName
        warn(s"DEBUG [enterTokensSpec]: Declared token: '$tokenName'")
      }
    }
  }

  override def enterLexerRuleSpec(ctx: LexerRuleSpecContext): Unit = {
    val tokenName = ctx.TOKEN_REF().getText
    warn(s"DEBUG [enterLexerRuleSpec]: Processing potential token definition for: '$tokenName'")

    if (tokenName == specialVarSymbolName) {
      warn(s"DEBUG [enterLexerRuleSpec]: Skipping '$tokenName' as it matches specialVarSymbolName and should be a parser rule.")
      return
    }
    declaredTokenNames += tokenName
    try {
      if (ctx.lexerRuleBlock() != null &&
        ctx.lexerRuleBlock().lexerAltList() != null &&
        !ctx.lexerRuleBlock().lexerAltList().lexerAlt().isEmpty &&
        ctx.lexerRuleBlock().lexerAltList().lexerAlt(0).lexerElements() != null &&
        !ctx.lexerRuleBlock().lexerAltList().lexerAlt(0).lexerElements().lexerElement().isEmpty &&
        ctx.lexerRuleBlock().lexerAltList().lexerAlt(0).lexerElements().lexerElement(0).lexerAtom() != null &&
        ctx.lexerRuleBlock().lexerAltList().lexerAlt(0).lexerElements().lexerElement(0).lexerAtom().terminalDef() != null &&
        ctx.lexerRuleBlock().lexerAltList().lexerAlt(0).lexerElements().lexerElement(0).lexerAtom().terminalDef().STRING_LITERAL() != null) {
        val literal = stripQuotes(ctx.lexerRuleBlock().lexerAltList().lexerAlt(0).lexerElements().lexerElement(0).lexerAtom().terminalDef().STRING_LITERAL().getText)
        tokenLiterals += (tokenName -> literal)
        warn(s"DEBUG [enterLexerRuleSpec]: Defined token: '$tokenName' with literal: '$literal'")
      } else {
        warn(s"DEBUG [enterLexerRuleSpec]: Declared token: '$tokenName' (complex pattern, no simple literal extracted)")
      }
    } catch {
      case e: Exception => warn(s"DEBUG [enterLexerRuleSpec]: Error parsing literal for token '$tokenName', declared as pattern.")
    }
  }

  override def enterParserRuleSpec(ctx: ParserRuleSpecContext): Unit = {
    val ruleName = ctx.RULE_REF().getText
    currentRuleName = Some(ruleName)
    currentAlternatives = mutable.ListBuffer()
    if (firstParserRuleName.isEmpty) {
      firstParserRuleName = Some(ruleName)
    }
    warn(s"DEBUG [enterParserRuleSpec]: Entering rule '$ruleName'")
  }

  override def exitParserRuleSpec(ctx: ParserRuleSpecContext): Unit = {
    currentRuleName.foreach { name =>
      if (currentAlternatives.nonEmpty) {
        rules += (name -> ProductionRule(name, currentAlternatives.toList))
        warn(s"DEBUG [exitParserRuleSpec]: Added rule '$name' with ${currentAlternatives.length} alternatives.")
      } else {
        warn(s"WARNING [exitParserRuleSpec]: Rule '$name' has no alternatives, not adding to map.")
      }
    }
    currentRuleName = None
  }

  override def enterAlternative(ctx: AlternativeContext): Unit = {
    currentSymbolsInAlternative = mutable.ListBuffer()
    // warn(s"DEBUG [enterAlternative]: For rule ${currentRuleName.getOrElse("UNKNOWN")}")
  }

  override def exitAlternative(ctx: AlternativeContext): Unit = {
    currentAlternatives += ProductionAlternative(currentSymbolsInAlternative.toList)
  }

  override def enterElement(ctx: ElementContext): Unit = {
    var baseSymbolOpt: Option[GrammarSymbol] = None
    val currentElementText = ctx.getText

    if (ctx.atom() != null) {
      val atom = ctx.atom()

      if (atom.ruleref() != null) {
        val ruleName = atom.ruleref().RULE_REF().getText
        warn(s"DEBUG [enterElement for '$currentElementText']: Found RULEREF: '$ruleName'. specialVarSymbolName is '$specialVarSymbolName'")
        if (ruleName == specialVarSymbolName) {
          warn(s"DEBUG [enterElement]: Matched specialVarSymbolName. Creating VarPlaceholder for '$ruleName'.")
          baseSymbolOpt = Some(VarPlaceholder(ruleName))
        } else {
          baseSymbolOpt = Some(NonTerminal(ruleName))
        }
      }
      else if (atom.terminalDef() != null) {
        val terminalCtx = atom.terminalDef()
        if (terminalCtx.TOKEN_REF() != null) {
          val tokenName = terminalCtx.TOKEN_REF().getText
          warn(s"DEBUG [enterElement for '$currentElementText']: Found TOKEN_REF: '$tokenName'")
          val tokenActualValue = tokenLiterals.getOrElse(tokenName, s"[$tokenName PatternRef]")
          baseSymbolOpt = Some(Terminal(tokenName, tokenActualValue))
        } else if (terminalCtx.STRING_LITERAL() != null) {
          val literalValue = stripQuotes(terminalCtx.STRING_LITERAL().getText)
          warn(s"DEBUG [enterElement for '$currentElementText']: Found STRING_LITERAL: '$literalValue'")
          baseSymbolOpt = Some(Terminal(literalValue, literalValue))
        }
      } else if (atom.wildcard() != null) {
        val dotText = atom.wildcard().getText
        baseSymbolOpt = Some(Terminal(dotText, dotText))
      }

  } else if (ctx.ebnf() != null) {
      val ebnfCtx = ctx.ebnf()
      if (ebnfCtx.block() != null && ebnfCtx.block().altList() != null && !ebnfCtx.block().altList().alternative().isEmpty) {
        val blockText = ebnfCtx.block().getText
        warn(s"WARNING [enterElement->ebnf]: EBNF block '$blockText' encountered. Simplified handling.")
        baseSymbolOpt = Some(NonTerminal(s"[[EBNF_BLOCK: ${ebnfCtx.block().getText()}]]"))

      } else {
        baseSymbolOpt = Some(NonTerminal(s"[[EBNF_EMPTY_OR_SIMPLE: ${ebnfCtx.getText()}]]"))
      }
    } else if (ctx.actionBlock() != null) {
    warn(s"DEBUG [enterElement]: Skipping actionBlock: ${ctx.actionBlock().getText}")
    return
  }

    baseSymbolOpt.foreach { sym =>
      var finalSymbol: GrammarSymbol = sym
      if (ctx.ebnfSuffix() != null) {
        val suffixText = ctx.ebnfSuffix().getText
        suffixText.charAt(0) match {
          case '?' => finalSymbol = Optional(sym)
          case '*' => finalSymbol = ZeroOrMore(sym)
          case '+' => finalSymbol = OneOrMore(sym)
          case _   =>
        }
      }
      currentSymbolsInAlternative += finalSymbol
    }
  }
}


---

File: ./EvaluatorModel.scala
package com.beepboop.app

import com.beepboop.app.components.BinaryExpression

trait ExpressionConfig  extends Serializable {
// config similar to LogTrait and LogConfigProvider
  // type of mutation, turned on per Type of Expression
  // max depth ( global, lokalne )
}


// Type of mutations:
/*
change expression
change variable
change parameter
create nonterminal expression
be constant

*/

def stringWithSpaces(strings: String*): String = {
  strings.mkString(" ")
}


// GrammarT - Terminal / NonTerminal
sealed trait Expression[ReturnT] extends ExpressionConfig with Serializable {
  def toString: String

  def eval: ReturnT
  // figure out how to inform about return type to allow type checking
  def distance: Any // type for heuristic Merge with Constraint Boundary Checker

  // something like this:
  // if ( depth > maxDepth ) {
  // Expression[Terminal, Any], Expression[Terminal, Any]
  //   }
}

/*

case class BinaryExpression[Boolean](left: components.Expression[Any], operator: Operator[Boolean], right: components.Expression[Any]) extends components.Expression {
  override def eval: Boolean = {
    operator.eval(left, right)
  }
  override def toString: String = {
    stringWithSpaces(left.toString, operator.toString, right.toString)
  }
}


case class UnaryExpression(operator: String, expression: components.Expression) extends components.Expression
case class Variable(name: String) extends components.Expression
case class Constant(value: Int) extends components.Expression

case class Forall(variableName: String, start: Int, end: Int, body: components.Expression) extends components.Expression
// TODO: LIST -> (array, range) , var iterate, expression

case class Exists(variableName: String, start: Int, end: Int, body: components.Expression) extends components.Expression
// TODO: LIST -> (array, range) , var iterate, expression


case class Operator(op: String)

case class EvaluableConstraint(left: Variable, op: Operator, right: Variable)


case class Sum(
                variables: List[Variable],
                operator: String,
                limit: components.Expression
              ) extends components.Expression

case class AllDifferent(
                         variables: List[Variable]
                       ) extends components.Expression

case class Count(
                  variables: List[Variable],
                  value: components.Expression,
                  operator: String,
                  count: components.Expression
                ) extends components.Expression


case class Lexicographical(
                            left: List[Variable],
                            operator: String,
                            right: List[Variable]
                          ) extends components.Expression



case class Minimum(
                    variables: List[Variable],
                    operator: String,
                    limit: components.Expression
                  ) extends components.Expression

case class Maximum(
                    variables: List[Variable],
                    operator: String,
                    limit: components.Expression
                  ) extends components.Expression



case class Task(
                 start: Variable,
                 duration: Variable,
                 demand: Variable
               )


case class Cumulative(
                       tasks: List[Task],
                       operator: String,
                       limit: components.Expression
                     ) extends components.Expression

case class ValuePrecedeChain(
                              valuesToPrecede: List[Int],
                              variables: List[Variable]
                            ) extends components.Expression

case class GlobalCardinality(
                              variables: List[Variable],
                              expectedCounts: Map[Int, Int]
                            ) extends components.Expression

case class Diffn(
                  rects: List[RectDescriptor]
                ) extends components.Expression

case class RectDescriptor(
                           x: components.Expression,
                           y: components.Expression,
                           width: components.Expression,
                           height: components.Expression
                         ) extends components.Expression

case class RedundantConstraint(
                                innerConstraint: components.Expression
                              ) extends components.Expression

case class StrEq(
                  s1: components.Expression,
                  s2: components.Expression
                ) extends components.Expression

object EvaluatorModel {
  def expressionToString(expr: components.Expression): String = expr match {
    case BinaryExpression(left, op, right) => s"(${expressionToString(left)} $op ${expressionToString(right)})"
    case UnaryExpression(op, expression) => s"$op(${expressionToString(expression)})"
    case Variable(name) => name
    case Constant(value) => value.toString
    case Forall(variableName, start, end, body) => s"forall ($variableName in $start..$end) (${expressionToString(body)})"
    case Exists(variableName, start, end, body) => s"exists ($variableName in $start..$end) (${expressionToString(body)})"

    case s: Sum =>
      s"sum([${s.variables.map(_.name).mkString(", ")}]) ${s.operator} ${expressionToString(s.limit)}"
    case ad: AllDifferent =>
      s"alldifferent([${ad.variables.map(_.name).mkString(", ")}])"
    case c: Count =>
      s"count([${c.variables.map(_.name).mkString(", ")}], ${expressionToString(c.value)}) ${c.operator} ${expressionToString(c.count)}"
    case l: Lexicographical =>
      s"lex_${l.operator}([${l.left.map(_.name).mkString(", ")}], [${l.right.map(_.name).mkString(", ")}])"
    case m: Minimum =>
      s"min([${m.variables.map(_.name).mkString(", ")}]) ${m.operator} ${expressionToString(m.limit)}"
    case m: Maximum =>
      s"max([${m.variables.map(_.name).mkString(", ")}]) ${m.operator} ${expressionToString(m.limit)}"
    case c: Cumulative =>
      s"cumulative([${c.tasks.map(t => s"task(${expressionToString(t.start)},${expressionToString(t.duration)},${expressionToString(t.demand)})").mkString(", ")}]) ${c.operator} ${expressionToString(c.limit)}"
    case vpc: ValuePrecedeChain =>
      s"value_precede_chain([${vpc.valuesToPrecede.mkString(", ")}], [${vpc.variables.map(_.name).mkString(", ")}])"
    case gc: GlobalCardinality =>
      s"global_cardinality([${gc.variables.map(_.name).mkString(", ")}], {${gc.expectedCounts.map { case (v, count) => s"$v:$count" }.mkString(", ")}})"
    case d: Diffn =>
      s"diffn([${d.rects.map(r => s"rect(${expressionToString(r.x)},${expressionToString(r.y)},${expressionToString(r.width)},${expressionToString(r.height)})").mkString(", ")}])"
    case rc: RedundantConstraint =>
      s"redundant(${expressionToString(rc.innerConstraint)})"
    case se: StrEq =>
      s"str_eq(${expressionToString(se.s1)}, ${expressionToString(se.s2)})"

    case r: RectDescriptor =>
      s"rect_desc(x:${expressionToString(r.x)}, y:${expressionToString(r.y)}, w:${expressionToString(r.width)}, h:${expressionToString(r.height)})"
    case t: Task =>
      s"task_desc(s:${expressionToString(t.start)}, d:${expressionToString(t.duration)}, dem:${expressionToString(t.demand)})"


    case other => s"UNSUPPORTED_EXPR_TYPE[${other.getClass.getSimpleName}]"
  }
  // this should be removed
  def evaluateStringExpression(expr: components.Expression, solution: Map[String, Int]): List[Int] = expr match {
    case Variable(name) => name.map(_.toInt).toList
    case Constant(value) => List(value)
    case _ => List.empty[Int]
  }
}

*/

---

File: ./MinizincModelListener.scala
package com.beepboop.app

import com.beepboop.parser.NewMinizincParserBaseListener
import com.beepboop.parser.NewMinizincParser.Var_decl_itemContext
import org.antlr.v4.runtime.misc.Interval
import org.antlr.v4.runtime.{CommonTokenStream, ParserRuleContext}
import com.beepboop.app.dataprovider.*

import scala.collection.mutable.ListBuffer
import scala.jdk.CollectionConverters.*

class MinizincModelListener(tokens: CommonTokenStream, extendedDataType: Boolean = true) extends NewMinizincParserBaseListener {

  private val dataItemsBuffer = new ListBuffer[DataItem]()

  def getDataItems: List[DataItem] = dataItemsBuffer.toList

  private def textWithSpaces(ctx: ParserRuleContext): String = {
    if (ctx == null) return ""
    val start = ctx.getStart.getTokenIndex
    val stop = ctx.getStop.getTokenIndex
    tokens.getText(new Interval(start, stop))
  }


  override def enterVar_decl_item(ctx: Var_decl_itemContext): Unit = {
    assert(ctx != null)
    var name =
      if (ctx.ident() == null) ctx.ti_expr_and_id().ident().getText
      else ctx.ident().getText

    var fullType = ""
    var detailedFullType = DataType(null, false, false)
    var expr = ""
    var isVar = false


    if (ctx.ti_expr_and_id().ti_expr().array_ti_expr() != null) {
     if (ctx.ti_expr_and_id().ti_expr().array_ti_expr().base_ti_expr().var_par().getText != "var")
     {
       // not var
       fullType = textWithSpaces(ctx.ti_expr_and_id().ti_expr().array_ti_expr())
       if (ctx.ti_expr_and_id().ti_expr().array_ti_expr().base_ti_expr().base_ti_expr_tail().base_type() == null) {
         detailedFullType = DataType(textWithSpaces(ctx.ti_expr_and_id().ti_expr().array_ti_expr().base_ti_expr().base_ti_expr_tail().ident()), true, true)
       } else {
         detailedFullType = DataType(textWithSpaces(ctx.ti_expr_and_id().ti_expr().array_ti_expr().base_ti_expr().base_ti_expr_tail().base_type()), true, false)
       }

       // try to get expression for given decl Item, useful for set of int?
       if (ctx.expr() != null) {
         expr = ctx.expr().getText
       }
     } else {
       fullType = textWithSpaces(ctx.ti_expr_and_id().ti_expr().array_ti_expr())
       if (ctx.ti_expr_and_id().ti_expr().array_ti_expr().base_ti_expr().base_ti_expr_tail().base_type() == null) {
         if (ctx.ti_expr_and_id().ti_expr().array_ti_expr().base_ti_expr().base_ti_expr_tail().ident() != null) {
           detailedFullType = DataType(textWithSpaces(ctx.ti_expr_and_id().ti_expr().array_ti_expr().base_ti_expr().base_ti_expr_tail().ident()), true, true)
         } else {
           detailedFullType = DataType(textWithSpaces(ctx.ti_expr_and_id().ti_expr().array_ti_expr()), true, true)
         }
       } else {
         detailedFullType = DataType(textWithSpaces(ctx.ti_expr_and_id().ti_expr().array_ti_expr().base_ti_expr().base_ti_expr_tail().base_type()), true, false)
       }
       isVar = true
     }

    } else if (ctx.ti_expr_and_id().ti_expr().base_ti_expr() != null)  {
        if (ctx.ti_expr_and_id().ti_expr().base_ti_expr().var_par().getText != "var") {
          fullType = textWithSpaces(ctx.ti_expr_and_id().ti_expr().base_ti_expr())
          detailedFullType = DataType(textWithSpaces(ctx.ti_expr_and_id().ti_expr().base_ti_expr().base_ti_expr_tail().base_type()), false, false, Option(ctx.ti_expr_and_id().ti_expr().base_ti_expr().set_ti() != null).getOrElse(false))
        } else {
          fullType = textWithSpaces(ctx.ti_expr_and_id().ti_expr().base_ti_expr())
          if (ctx.ti_expr_and_id().ti_expr().base_ti_expr().base_ti_expr_tail().base_type() == null){
            if (ctx.ti_expr_and_id().ti_expr().base_ti_expr().base_ti_expr_tail().ident() != null){
              detailedFullType = DataType(textWithSpaces(ctx.ti_expr_and_id().ti_expr().base_ti_expr().base_ti_expr_tail().ident()), false, true)
            } else {
              detailedFullType = DataType(textWithSpaces(ctx.ti_expr_and_id().ti_expr()), false, true)
            }
          } else {
            detailedFullType = DataType(textWithSpaces(ctx.ti_expr_and_id().ti_expr().base_ti_expr().base_ti_expr_tail().base_type()), false, false)
          }
          isVar = true
        }

        if (ctx.expr() != null) {
          expr = ctx.expr().getText
        }
    }

    val dataItem = if(extendedDataType){
      DataItem(name = name, dataType = fullType, isVar = isVar, detailedDataType = detailedFullType, expr = expr)
    } else {
     DataItem(name = name, dataType = fullType, isVar = isVar, detailedDataType = null, expr = expr)
    }
    dataItemsBuffer += dataItem
  }
}

---

File: ./MainApp.scala
package com.beepboop.app

import com.beepboop.app.astar.AStar
import com.beepboop.app.components.{BinaryExpression, BoolType, ComponentRegistry, Constant, EqualOperator, Expression, GreaterOperator, IntType, Variable}
import com.beepboop.app.cpicker.{ConstraintPicker, ConstraintSaver, Runner}
import com.beepboop.app.dataprovider.DataProvider
import com.beepboop.app.logger.Profiler
import com.beepboop.app.mutations.{AllMutations, ExpressionGenerator, MutationEngine}
import com.typesafe.scalalogging.*
import org.antlr.v4.runtime.tree.ParseTreeWalker
import org.antlr.v4.runtime.{CharStream, CharStreams, CommonTokenStream, TokenStream}
import com.beepboop.app.dataprovider.PersistenceManager
import com.beepboop.app.utils.AppConfig
import debugger.VisualDebugger
//import com.beepboop.app.utils.{GeneratorConfig, ArgumentParser}
import com.beepboop.app.utils.ArgumentParser
//import mainargs.{main, arg, ParserForClass, Flag}

import scala.collection.mutable.ArrayBuffer
import scala.io.Source
import scala.util.{Failure, Success}

// logging
import com.beepboop.app.logger.LogTrait


object MainApp extends LogTrait {

  def main(args: Array[String]): Unit = {

    val configOpt = ArgumentParser.parse(args)
    if (configOpt.isEmpty) return
    val config = configOpt.get

    info("--- Step 1: Configuration ---")
    info(s"Model: ${config.modelPath}")
    info(s"Max Iterations: ${config.maxIterations}")
    info(s"Output CSV: ${config.outputCsv}")
    info(s"Checkpoint File: ${config.checkpointFile}")
    info(s"Resume mode: ${config.resume}")
    info("Loading parsed constraint grammar...")
    val internalGrammar: ParsedGrammar = GrammarConverter.parseConstraintGrammar()
    debug(ParsedGrammar.toString)

    DataProvider.initalize(
      config.modelPath,
      config.dataPath,
      config.solutionsPath.getOrElse("models/accap_sols_a10.csv")
    )
    if (config.debug) {
      info("--- Launching Visual Debugger ---")
      VisualDebugger.launch(config.checkpointFile)
      return;
    }


    info("\n--- Step 2: Invoking Mutation Engine ---")
    val mutationEngine = new MutationEngine(AllMutations.mutations)

    val searcher = new AStar(internalGrammar)

    if (config.resume) {
      info(s"Attempting to resume from ${config.checkpointFile}...")
      PersistenceManager.loadAStarState(config.checkpointFile) match {
        case Success(snapshot) =>
          searcher.restoreState(snapshot)
          info("Resume successful.")
        case Failure(e) =>
          warn(s"Failed to load checkpoint: ${e.getMessage}. Starting from scratch.")
      }
    }

    Runtime.getRuntime.addShutdownHook(new Thread(() => {
      val snapshot = searcher.getSnapshot
      if (snapshot.openSetItems.nonEmpty || snapshot.visitedItems.nonEmpty) {
        PersistenceManager.performEmergencyBackup(snapshot, config.checkpointFile, config.outputCsv)
      }
    }))

    val initialExpr = ExpressionGenerator.generate(requiredType = BoolType, maxDepth = 2)
      .getOrElse(Constant(value = false))

    info("--- Step 3: Starting Optimization Loop ---")

    val result = searcher.findOptimalModel(
      initialConstraint = initialExpr,
      availableVars = DataProvider.variables,
      dataPars = DataProvider.parameters,
      maxIterations = config.maxIterations,
      saveInterval = config.saveInterval,
      checkpointFile = config.checkpointFile,
      outputCsvFile = config.outputCsv
    )

    result.foreach { nodes =>
      info(s"Search completed. Saving ${nodes.size} constraints to CSV...")
      PersistenceManager.saveConstraintsToCSV(nodes, config.outputCsv)
    }


    info("--- Step 4. Starting constraint picking ---")

    ConstraintSaver.setConfig(config)

    ConstraintPicker.setConfig(config)
    /* vvv comment if no gurobi license present vvv */
    //ConstraintPicker.runInitial(result.get)




    Profiler.report()
    Profiler.reset()





  }
}

---

File: ./repo.txt


---

File: ./astar/AStar.scala
package com.beepboop.app.astar

import com.beepboop.app.*
import com.beepboop.app.components.{BinaryExpression, Expression}
import com.beepboop.app.dataprovider.{DataItem, DataProvider}
import com.beepboop.app.logger.LogTrait
import com.beepboop.app.logger.Profiler
import com.beepboop.app.mutations.{AllMutations, MutationEngine}
import com.beepboop.parser.{ModelConstraintGrammarLexer, ModelConstraintGrammarParser}
import com.typesafe.scalalogging.LazyLogging
import org.antlr.v4.runtime.{CharStreams, CommonTokenStream}

import scala.collection.parallel.CollectionConverters.RangeIsParallelizable
import com.beepboop.app.dataprovider.{AStarSnapshot, PersistenceManager}
import com.beepboop.app.policy.{Compliant, DenyDivByZero, EnsureAnyVarExists, NonCompliant, Scanner}
import com.beepboop.app.postprocessor.Postprocessor

import scala.collection.mutable
import scala.reflect.ClassTag
import scala.util.Random
import scala.util.control.NonFatal


case class ModelNode(
                      constraints: List[Expression[?]],
                      g: Int,
                      h: Int,
                      parent: Option[ModelNode]
                    ) {
  val f: Int = g + h
}


case class ModelNodeTMP(
                         constraint: Expression[?],
                         g: Int,
                         h: Int,
                       ) extends Serializable {
  val f: Int = g + h
}

case class HeuristicStats(
                           satisfiedCount: Int,
                           totalNormalizedDistance: Double,
                           minNormalizedDistance: Double,
                           maxNormalizedDistance: Double,
                           sumSquaredNormalizedDistance: Double,
                           numSolutions: Int
                         )

object ModelNodeOrdering extends Ordering[ModelNode] {
  def compare(a: ModelNode, b: ModelNode): Int = b.f.compare(a.f)
}

object ModelNodeTMPOrdering extends Ordering[ModelNodeTMP] {
  def compare(a: ModelNodeTMP, b: ModelNodeTMP): Int = b.f.compare(a.f)
}


case class DerivationNode(
                           sequence: List[GrammarSymbol],
                           g: Int,
                           h: Int,
                           parent: Option[DerivationNode]
                         ) {
  val f: Int = g + h
}

object DerivationNodeOrdering extends Ordering[DerivationNode] {
  def compare(a: DerivationNode, b: DerivationNode): Int = b.f.compare(a.f)
}


class AStar(grammar: ParsedGrammar) extends LogTrait {
  private val numSolutions = DataProvider.solutionCount
  private val mutationEngine = new MutationEngine(AllMutations.mutations)

  private val openSet = mutable.PriorityQueue[ModelNodeTMP]()(ModelNodeTMPOrdering)
  private val visited = mutable.Map[Expression[?], ModelNodeTMP]()
  private var isInitialized = false

  def getSnapshot: AStarSnapshot = {
    val visitedNodes = visited.values.toSet
    AStarSnapshot(openSet.toList, visitedNodes)
  }

  def restoreState(snapshot: AStarSnapshot): Unit = {
    this.openSet.clear()
    this.visited.clear()
    snapshot.openSetItems.foreach(item => this.openSet.enqueue(item))

    snapshot.visitedItems.foreach(node => visited(node.constraint) = node)

    this.isInitialized = true
    warn(s"State restored! Queue: ${openSet.size}, Visited: ${visited.size}")
  }

  def findOptimalModel(
                        initialConstraint: Expression[?],
                        availableVars: List[DataItem],
                        dataPars: List[DataItem],
                        maxIterations: Int,
                        saveInterval: Int,
                        checkpointFile: String,
                        outputCsvFile: String
                      ): Option[mutable.Set[ModelNodeTMP]] = {

    if (!isInitialized) {
      openSet.clear()
      visited.clear()

      val initial_h = calculateHeuristic(initialConstraint)
      val startNode = ModelNodeTMP(initialConstraint, 1, initial_h)
      warn(s"Start Node: g=${startNode.g}, h=${startNode.h}, f=${startNode.f}")
      openSet.enqueue(startNode)
    }
    else {
      warn("Resuming search from loaded state...")
    }

    var iterations = 0

    while (openSet.nonEmpty && iterations < maxIterations) {
      if (iterations % saveInterval == 0 && iterations > 0) {
        PersistenceManager.saveCheckpoint(getSnapshot, checkpointFile, outputCsvFile)
        warn(s"Checkpoint saved at iteration $iterations.")
      }

      Some(visited)

      info(s"Iteration: $iterations. Queue items: ${openSet.size}. Visited: ${visited.size}")
      iterations += 1
      val currentNode = openSet.dequeue()
      info(s"Dequeuing node: $currentNode")

      visited(currentNode.constraint) = currentNode
      debug(visited.toString)
      val generated = generateNeighbors(currentNode)
      info(s"Generated neighbors: ${generated.size}")
      generated.foreach { neighborConstraint =>
        if (!visited.contains(neighborConstraint)) {
          val h = calculateHeuristic(neighborConstraint)
          val neighbourNode = ModelNodeTMP(neighborConstraint, currentNode.g + 1, h)
          //debug(s"Enqueuing node: $neighbourNode")
          openSet.enqueue(neighbourNode)
        }
      }
    }

    info("Saving final state checkpoint...")
    PersistenceManager.saveCheckpoint(getSnapshot, checkpointFile, outputCsvFile)
    info(s"Search finished after $iterations iterations.")
    isInitialized = false
    warn(s"Search finished after $iterations iterations without finding a solution.")
    val resultNodes = scala.collection.mutable.Set.from(visited.values)
    Some(resultNodes)
  }

  private def calculateHeuristic(constraint: Expression[?]): Int = Profiler.profile("calculateHeuristic") {
    if (numSolutions == 0) return Int.MaxValue

    val(satisfiedCount, totalNormDist, minNormDist, maxNormDist, sumSqNormDist) = (0 until numSolutions).par.map { i =>
      try {
        val context = DataProvider.createSolutionContext(i)

        val isSatisfied = try constraint.eval(context).asInstanceOf[Boolean] catch {
          case _: ClassCastException => false
          case _: Exception => false
        }

        if (isSatisfied) (1, 0.0, 0.0, 0.0, 0.0) else {
          val rawDist = constraint.distance(context)
          val normDist = rawDist.toDouble / (1.0 + rawDist.toDouble)
          val sqDist = normDist * normDist
          (0, normDist, normDist, normDist, sqDist)
        }
      } catch {
        case scala.util.control.NonFatal(e) => (0, 1.0, 1.0, 0.0, 0.0)
      }
    }.fold((0, 0.0, 1.0, 0.0, 0.0)) { (acc, elem) =>
      (
        acc._1 + elem._1,
        acc._2 + elem._2,
        math.min(acc._3, elem._3),
        math.max(acc._4, elem._4),
        acc._5 + elem._5
      )
    }

    val stats = HeuristicStats(satisfiedCount, totalNormDist, minNormDist, maxNormDist, sumSqNormDist, numSolutions)
    // different heuristic calculation methods; uncomment to activate, average is default
     computeHeuristicScoreAverage(stats)      // method 1 (standard - distance average)
    // computeHeuristicScoreMinDist(stats)      // method 2 (optimistic - min distance)
    // computeHeuristicScoreMaxDist(stats)      // method 3 (pessimistic - max distance)
    // computeHeuristicScoreMSE(stats)             // method 4 (squared - squared distance)
    // computeHeuristicScoreVariance(stats)     // method 5 (variance - distance variance)
  }

  private def computeHeuristicScoreAverage(stats: HeuristicStats): Int = {
    val beta = 2.0
    val betaSq = beta * beta
    val SCALING_FACTOR = 1000

    val satisfactionRate = stats.satisfiedCount.toDouble / stats.numSolutions.toDouble
    val avgNormDist = stats.totalNormalizedDistance / stats.numSolutions.toDouble
    val closenessRate = 1.0 - avgNormDist

    if (satisfactionRate == 0.0 && closenessRate == 0.0) {
      return SCALING_FACTOR
    }

    val numerator = (1.0 + betaSq) * (closenessRate * satisfactionRate)
    val fScoreDenominator = (betaSq * closenessRate) + satisfactionRate

    val fScore = if (fScoreDenominator == 0) 0.0 else numerator / fScoreDenominator
    ((1.0 - fScore) * SCALING_FACTOR).toInt
  }

  private def computeHeuristicScoreMinDist(stats: HeuristicStats): Int = {
    val beta = 2.0
    val betaSq = beta * beta
    val SCALING_FACTOR = 1000

    val satisfactionRate = stats.satisfiedCount.toDouble / stats.numSolutions.toDouble

    val closenessRate = 1.0 - stats.minNormalizedDistance

    if (satisfactionRate == 0.0 && closenessRate == 0.0) {
      return SCALING_FACTOR
    }

    val numerator = (1.0 + betaSq) * (closenessRate * satisfactionRate)
    val fScoreDenominator = (betaSq * closenessRate) + satisfactionRate

    val fScore = if (fScoreDenominator == 0) 0.0 else numerator / fScoreDenominator
    ((1.0 - fScore) * SCALING_FACTOR).toInt
  }

  private def computeHeuristicScoreMaxDist(stats: HeuristicStats): Int = {
    val beta = 2.0
    val betaSq = beta * beta
    val SCALING_FACTOR = 1000

    val satisfactionRate = stats.satisfiedCount.toDouble / stats.numSolutions.toDouble

    val closenessRate = 1.0 - stats.maxNormalizedDistance

    if (satisfactionRate == 0.0 && closenessRate == 0.0) return SCALING_FACTOR

    val numerator = (1.0 + betaSq) * (closenessRate * satisfactionRate)
    val denominator = (betaSq * closenessRate) + satisfactionRate

    val fScore = if (denominator == 0) 0.0 else numerator / denominator
    ((1.0 - fScore) * SCALING_FACTOR).toInt
  }

  private def computeHeuristicScoreMSE(stats: HeuristicStats): Int = {
    val beta = 2.0
    val betaSq = beta * beta
    val SCALING_FACTOR = 1000

    val satisfactionRate = stats.satisfiedCount.toDouble / stats.numSolutions.toDouble

    val meanSquaredError = stats.sumSquaredNormalizedDistance / stats.numSolutions.toDouble
    val rootMeanSquaredError = math.sqrt(meanSquaredError)

    val closenessRate = 1.0 - rootMeanSquaredError

    if (satisfactionRate == 0.0 && closenessRate <= 0.0) return SCALING_FACTOR

    val numerator = (1.0 + betaSq) * (closenessRate * satisfactionRate)
    val denominator = (betaSq * closenessRate) + satisfactionRate

    val fScore = if (denominator == 0) 0.0 else numerator / denominator
    ((1.0 - fScore) * SCALING_FACTOR).toInt
  }

  private def computeHeuristicScoreVariance(stats: HeuristicStats): Int = {
    val beta = 2.0
    val betaSq = beta * beta
    val SCALING_FACTOR = 1000

    val satisfactionRate = stats.satisfiedCount.toDouble / stats.numSolutions.toDouble

    val mean = stats.totalNormalizedDistance / stats.numSolutions.toDouble
    val meanSq = stats.sumSquaredNormalizedDistance / stats.numSolutions.toDouble
    val variance = math.max(0.0, meanSq - (mean * mean))
    val stdDev = math.sqrt(variance)

    val lambda = 0.5
    val penalizedDist = math.min(1.0, mean + (lambda * stdDev))

    val closenessRate = 1.0 - penalizedDist

    if (satisfactionRate == 0.0 && closenessRate <= 0.0) return SCALING_FACTOR

    val numerator = (1.0 + betaSq) * (closenessRate * satisfactionRate)
    val denominator = (betaSq * closenessRate) + satisfactionRate

    val fScore = if (denominator == 0) 0.0 else numerator / denominator
    ((1.0 - fScore) * SCALING_FACTOR).toInt
  }

  private def calculateGlobalHeuristic(constraints: List[Expression[?]], availableVars: List[DataItem], dataPars: List[DataItem]): Int = {
    val numSolutions = availableVars.headOption
      .flatMap(item => Option(item.value))
      .collect { case l: List[?] => l.size }
      .getOrElse(0)

    if (constraints.isEmpty) return numSolutions
    if (numSolutions == 0) return 0


    constraints.map(c =>
      val totalDistance = (0 until numSolutions).map { solutionIndex =>  {
        val context = DataProvider.getSolutionContext(solutionIndex)
        constraints.map(c => c.distance(context)).sum
      }
      }.min
      info(s"Max distance for expression ${c.toString}: $totalDistance")
    )
    return 0;

  }

  private def generateNeighbors(node: ModelNodeTMP): List[Expression[?]] = {
    val constraint = node.constraint

    val possibleMutations = mutationEngine.collectPossibleMutations(constraint)

    val neighbors = possibleMutations.flatMap {
      case (targetNode, mutationFunc, ctx) =>

        mutationFunc(targetNode, ctx).flatMap { replacement =>

          if (replacement.signature.output != targetNode.signature.output) {
            debug(s"Type Mismatch: ${targetNode.signature.output} vs ${replacement.signature.output}")
            None
          } else {
            val candidateTree = mutationEngine.replaceNodeInTree(constraint, targetNode, replacement)
            val simplifiedTree = candidateTree match {
              case expr: Expression[t] =>
                implicit val tag: ClassTag[t] = expr.ct
                Postprocessor.simplify(expr)
            }

            debug(s"Generated: $candidateTree to simplified $simplifiedTree")
            val result = Scanner.visitAll(simplifiedTree, EnsureAnyVarExists(), DenyDivByZero())

            if (result.isAllowed) {
              Profiler.recordValue("accepted", 1)
              Some(simplifiedTree)
            } else {
              debug(s"Expr: ${candidateTree.toString} - ${result.toString}")
              Profiler.recordValue("discarded", 1)
              result match {
                case nc: NonCompliant => Profiler.recordValue(nc.message, 1)
              }
              None
            }
          }
        }
    }
    debug(neighbors.toString)
    neighbors.toSet.toList
  }

  private def computeMinStepsHeuristic(): Map[String, Int] = {
    val costs = mutable.Map[String, Int]()
    grammar.rules.keys.foreach(name => costs(name) = Int.MaxValue)

    var changed = true
    while (changed) {
      changed = false
      for ((ruleName, productionRule) <- grammar.rules) {
        val minAltCostOption = productionRule.alternatives.map { alt =>
          alt.symbols.collect {
            case nt: NonTerminal => costs.getOrElse(nt.name, Int.MaxValue)
          }.foldLeft(0L)(_ + _).toInt
        }.minOption

        minAltCostOption.foreach { minAltCost =>
          if (minAltCost != Int.MaxValue) {
            val newCost = 1 + minAltCost
            if (newCost < costs.getOrElse(ruleName, Int.MaxValue)) {
              costs(ruleName) = newCost
              changed = true
            }
          }
        }
      }
    }
    costs.toMap
  }

  private def calculateDerivationH(sequence: List[GrammarSymbol], minStepsHeuristic: Map[String, Int]): Int = {
    sequence.collect { case nt: NonTerminal =>
      minStepsHeuristic.getOrElse(nt.name, Int.MaxValue)
    }.sum
  }
}

---

File: ./components/Base.scala
package com.beepboop.app.components




---

File: ./components/Arithmetic.scala
package com.beepboop.app.components

/* third party modules */

/* own modules */


trait Addable[T] extends Serializable{
  def add(a: T, b: T): T
}

object Addable {
  implicit object IntIsAddable extends Addable[Integer] {
    override def add(a: Integer, b: Integer): Integer = a + b
  }
}


trait Subtractable[T] extends Serializable{
  def sub(a: T, b: T): T
}

object Subtractable {
  implicit object IntIsSubtractable extends Subtractable[Integer] {
    override def sub(a: Integer, b: Integer): Integer = a - b
  }
}

trait Multiplicable[T] extends Serializable{
  def mul(a: T, b: T): T
}

object Multiplicable {
  implicit object IntIsMultiplicable extends Multiplicable[Integer] {
    override def mul(a: Integer, b: Integer): Integer = a * b
  }
}

trait Divisible[T] extends Serializable{
  def div(a: T, b: T): T
}

object Divisible {
  implicit object IntIsDivisible extends Divisible[Integer] {
    override def div(a: Integer, b: Integer): Integer = {
      if(b == 0) return 0
      a / b
    }
  }
}

trait Modulable[T] extends Serializable{
  def mod(a: T, b: T): T
}

object Modulable {
  implicit object IntIsModulable extends Modulable[Integer] {
    override def mod(a: Integer, b: Integer): Integer = {
      if (b == 0) return 0
      a % b
    }
  }
}

trait Andable[T] extends Serializable{
  def and(a: T, b: T): T
}

object Andable {
  implicit object BoolIsAndable extends Andable[Boolean] {
    override def and(a: Boolean, b: Boolean): Boolean = a && b
  }
}

trait Orable[T] extends Serializable{
  def or(a: T, b: T): T
}

object Orable {
  implicit object BoolIsOrable extends Orable[Boolean] {
    override def or(a: Boolean, b: Boolean): Boolean = a || b
  }
}

trait Xorable[T] extends Serializable{
  def xor(a: T, b: T): T
}

object Xorable {
  implicit object BoolIsXorable extends Xorable[Boolean] {
    override def xor(a: Boolean, b: Boolean): Boolean = a ^ b
  }
}

trait Implies[T] extends Serializable{
  def implies(a: T, b: T): T
}

object Implies {
  implicit object BoolImplies extends Implies[Boolean] {
    override def implies(a: Boolean, b: Boolean): Boolean = !a || b
  }
}

trait Negatable[T] extends Serializable{
  def negate(a: T): T
}

object Negatable {
  implicit object IntIsNegatable extends Negatable[Integer] {
    override def negate(a: Integer): Integer = 0 - a
  }
}

trait Absolutable[T] extends Serializable{
  def abs(a: T): T
}

object Absolutable {
  implicit object IntIsAbsolutable extends Absolutable[Integer] {
    override def abs(a: Integer): Integer = java.lang.Math.abs(a)
  }
}

trait BoolToIntConvertible[T] extends Serializable{
  def convert(a: T): Integer
}

object BoolToIntConvertible {
  implicit object BoolIsConvertible extends BoolToIntConvertible[Boolean] {
    override def convert(a: Boolean): Integer = if (a) 1 else 0
  }
}





---

File: ./components/Operator.scala
package com.beepboop.app.components

/* third party */
import com.beepboop.app.utils.Implicits.integerNumeric

import scala.reflect.{ClassTag, classTag}

/* own modules */
import com.beepboop.app.components.{Addable, Andable, Contains, Divisible, Equatable, GreaterEqual, GreaterThan, Implies, LessEqual, LessThan, Modulable, Multiplicable, NotEquatable, Orable, Signature, Subtractable, Xorable}
import com.beepboop.app.components.{Addable, Signature, NotEquatable, Equatable, LessThan, GreaterThan, LessEqual, GreaterEqual, Negatable, Absolutable, BoolToIntConvertible}
import com.beepboop.app.components.{Addable, Signature, NotEquatable, Equatable, NotComputable}
import com.beepboop.app.logger.LogTrait


abstract class Operator[ReturnT](implicit val ct: ClassTag[ReturnT]) extends Serializable{

  def toString: String

  def signature: Signature

  def distance(left: Any, right: Any): Int = 0
}

abstract class UnaryOperator[ReturnT](implicit ct: ClassTag[ReturnT]) extends Operator[ReturnT] {
  def eval(expr: Any): ReturnT
}

abstract class BinaryOperator[ReturnT](implicit ct: ClassTag[ReturnT]) extends Operator[ReturnT] {
  def eval(left: Any, right: Any): ReturnT
}

case class AddOperator[T: ClassTag]()(implicit strategy: Addable[T]) extends BinaryOperator[T] {
  override def eval(left: Any, right: Any): T = {
    strategy.add(left.asInstanceOf[T], right.asInstanceOf[T])
  }

  override def toString: String = "+"

  override def signature: Signature = {
    val cls = classTag[T].runtimeClass
    val exprType = scalaTypeToExprType(cls)
    Signature(List(exprType, exprType), exprType)
  }
}


case class SubOperator[T: ClassTag]()(implicit strategy: Subtractable[T]) extends BinaryOperator[T] {
  override def eval(left: Any, right: Any): T = {
    strategy.sub(left.asInstanceOf[T], right.asInstanceOf[T])
  }

  override def toString: String = "-"

  override def signature: Signature = {
    val cls = classTag[T].runtimeClass
    val exprType = scalaTypeToExprType(cls)
    Signature(List(exprType, exprType), exprType)
  }
}


case class MulOperator[T: ClassTag]()(implicit strategy: Multiplicable[T]) extends BinaryOperator[T] {
  override def eval(left: Any, right: Any): T = {
    strategy.mul(left.asInstanceOf[T], right.asInstanceOf[T])
  }

  override def toString: String = "*"

  override def signature: Signature = {
    val cls = classTag[T].runtimeClass
    val exprType = scalaTypeToExprType(cls)
    Signature(List(exprType, exprType), exprType)
  }
}

case class DivOperator[T: ClassTag]()(implicit strategy: Divisible[T]) extends BinaryOperator[T] {
  override def eval(left: Any, right: Any): T = {
    strategy.div(left.asInstanceOf[T], right.asInstanceOf[T])
  }

  override def toString: String = "/"

  override def signature: Signature = {
    val cls = classTag[T].runtimeClass
    val exprType = scalaTypeToExprType(cls)
    Signature(List(exprType, exprType), exprType)
  }
}


case class ModOperator[T: ClassTag]()(implicit strategy: Modulable[T]) extends BinaryOperator[T] {
  override def eval(left: Any, right: Any): T = {
    strategy.mod(left.asInstanceOf[T], right.asInstanceOf[T])
  }

  override def toString: String = "%"

  override def signature: Signature = {
    val cls = classTag[T].runtimeClass
    val exprType = scalaTypeToExprType(cls)
    Signature(List(exprType, exprType), exprType)
  }
}



case class EqualOperator[T: ClassTag]()(implicit strategy: Equatable[T]) extends BinaryOperator[Boolean] {
  override def eval(left: Any, right: Any): Boolean = {
    strategy.equal(left.asInstanceOf[T], right.asInstanceOf[T])
  }
  override def toString: String = "="


  override def signature: Signature = {
    val cls = classTag[T].runtimeClass
    val exprType = scalaTypeToExprType(cls)
    Signature(List(exprType, exprType), BoolType)
  }

  override def distance(left: Any, right: Any): Int = {
    val leftT = left.asInstanceOf[T]
    val rightT = right.asInstanceOf[T]

    if (classOf[Number].isAssignableFrom(classTag[T].runtimeClass)) {
      Math.abs(leftT.asInstanceOf[Number].intValue() - rightT.asInstanceOf[Number].intValue())
    } else if (classOf[Set[?]].isAssignableFrom(classTag[T].runtimeClass)) {
      try {
        val s1 = leftT.asInstanceOf[Set[Any]]
        val s2 = rightT.asInstanceOf[Set[Any]]
        (s1 diff s2).size + (s2 diff s1).size
      } catch {
        case _: Exception => if (strategy.equal(leftT, rightT)) 0 else 1
      }
    } else {
      if (strategy.equal(leftT, rightT)) 0 else 1
    }
  }
}

case class NotEqualOperator[T: ClassTag]()(implicit strategy: NotEquatable[T]) extends BinaryOperator[Boolean] {
  override def eval(left: Any, right: Any): Boolean = {
    strategy.notEqual(left.asInstanceOf[T], right.asInstanceOf[T])
  }
  override def toString: String = "!="


  override def signature: Signature = {
    val cls = classTag[T].runtimeClass
    val exprType = scalaTypeToExprType(cls)
    Signature(List(exprType, exprType), BoolType)
  }


  override def distance(left: Any, right: Any): Int = {
    strategy.distance(left.asInstanceOf[T], right.asInstanceOf[T])
  }
}

case class ContainsOperator[L: ClassTag, R: ClassTag]()(implicit strategy: Contains[L, R]) extends BinaryOperator[Boolean] {
  override def eval(left: Any, right: Any): Boolean = strategy.contains(left.asInstanceOf[L], right.asInstanceOf[R])

  override def toString: String = "contains"

  override def signature: Signature = Signature(
    List(scalaTypeToExprType(classTag[L].runtimeClass), scalaTypeToExprType(classTag[R].runtimeClass)), BoolType
  )

  override def distance(left: Any, right: Any): Int = {
    strategy.distance(left.asInstanceOf[L], right.asInstanceOf[R])
  }
}

case class LessOperator[T: ClassTag]()(implicit strategy: LessThan[T]) extends BinaryOperator[Boolean] {
  override def eval(left: Any, right: Any): Boolean = strategy.less(left.asInstanceOf[T], right.asInstanceOf[T])
  override def toString: String = "<"
  override def signature: Signature = {
    val cls = classTag[T].runtimeClass
    val exprType = scalaTypeToExprType(cls)
    Signature(List(exprType, exprType), BoolType)
  }
  override def distance(left: Any, right: Any): Int = {
    val leftT = left.asInstanceOf[T]
    val rightT = right.asInstanceOf[T]

    if (leftT.isInstanceOf[Integer] && rightT.isInstanceOf[Integer]) {
      Math.abs(leftT.asInstanceOf[Integer] - (rightT.asInstanceOf[Integer] - 1))
    } else {
      if (strategy.less(leftT, rightT)) 0 else 1
    }
  }
}

case class LessEqualOperator[T: ClassTag]()(implicit strategy: LessEqual[T]) extends BinaryOperator[Boolean] {
  override def eval(left: Any, right: Any): Boolean = strategy.lessEqual(left.asInstanceOf[T], right.asInstanceOf[T])
  override def toString: String = "<="
  override def signature: Signature = {
    val cls = classTag[T].runtimeClass
    val exprType = scalaTypeToExprType(cls)
    Signature(List(exprType, exprType), BoolType)
  }
  override def distance(left: Any, right: Any): Int = {
    val leftT = left.asInstanceOf[T]
    val rightT = right.asInstanceOf[T]
    if (leftT.isInstanceOf[Integer] && rightT.isInstanceOf[Integer]) {
      Math.abs(leftT.asInstanceOf[Integer] - rightT.asInstanceOf[Integer])
    } else {
      if (strategy.lessEqual(leftT, rightT)) 0 else 1
    }
  }
}



case class GreaterOperator[T: ClassTag]()(implicit strategy: GreaterThan[T]) extends BinaryOperator[Boolean] {
  override def eval(left: Any, right: Any): Boolean = {
    strategy.greater(left.asInstanceOf[T], right.asInstanceOf[T])
  }
  override def toString: String = ">"

  override def signature: Signature = {
    val cls = classTag[T].runtimeClass
    val exprType = scalaTypeToExprType(cls)
    Signature(List(exprType, exprType), BoolType)
  }

  override def distance(left: Any, right: Any): Int = {
    val leftT = left.asInstanceOf[T]
    val rightT = right.asInstanceOf[T]
    if (leftT.isInstanceOf[Integer] && rightT.isInstanceOf[Integer]) {
      Math.abs(leftT.asInstanceOf[Integer] - (rightT.asInstanceOf[Integer] + 1))
    } else {
      if (strategy.greater(leftT, rightT)) 0 else 1
    }
  }

}

case class GreaterEqualOperator[T: ClassTag]()(implicit strategy: GreaterEqual[T]) extends BinaryOperator[Boolean] {
  override def eval(left: Any, right: Any): Boolean = {
    strategy.greaterEqual(left.asInstanceOf[T], right.asInstanceOf[T])
  }
  override def toString: String = ">="

  override def signature: Signature = {
    val cls = classTag[T].runtimeClass
    val exprType = scalaTypeToExprType(cls)
    Signature(List(exprType, exprType), BoolType)
  }


  override def distance(left: Any, right: Any): Int = {
    val leftT = left.asInstanceOf[T]
    val rightT = right.asInstanceOf[T]
    if (leftT.isInstanceOf[Integer] && rightT.isInstanceOf[Integer]) {
      Math.abs(leftT.asInstanceOf[Integer] - rightT.asInstanceOf[Integer])
    } else {
      if (strategy.greaterEqual(leftT, rightT)) 0 else 1
    }
  }
}

case class AndOperator[T: ClassTag]()(implicit strategy: Andable[T]) extends BinaryOperator[T] {
  override def eval(left: Any, right: Any): T = {
    strategy.and(left.asInstanceOf[T], right.asInstanceOf[T])
  }
  override def toString: String = "and"

  override def signature: Signature = Signature(List(BoolType, BoolType), BoolType)

  override def distance(left: Any, right: Any): Int = {
    if (eval(left, right).asInstanceOf[Boolean]) 0 else 1
  }
}

class OrOperator[T: ClassTag](implicit strategy: Orable[T]) extends BinaryOperator[T] {
  override def eval(left: Any, right: Any): T = {
    strategy.or(left.asInstanceOf[T], right.asInstanceOf[T])
  }
  override def toString: String = "or"

  override def signature: Signature = Signature(List(BoolType, BoolType), BoolType)


  override def distance(left: Any, right: Any): Int = {
    if (eval(left, right).isInstanceOf[Boolean]) 0 else 1
  }
}

case class XorOperator[T: ClassTag]()(implicit strategy: Xorable[T]) extends BinaryOperator[T] {
  override def eval(left: Any, right: Any): T = {
    strategy.xor(left.asInstanceOf[T], right.asInstanceOf[T])
  }
  override def toString: String = "xor"

  override def signature: Signature = Signature(List(BoolType, BoolType), BoolType)

  override def distance(left: Any, right: Any): Int = {
    if (eval(left, right).asInstanceOf[Boolean]) 0 else 1
  }
}

case class ImpliesOperator[T: ClassTag]()(implicit strategy: Implies[T]) extends BinaryOperator[T] {
  override def eval(left: Any, right: Any): T = {
    strategy.implies(left.asInstanceOf[T], right.asInstanceOf[T])
  }
  override def toString: String = "->"

  override def signature: Signature = Signature(List(BoolType, BoolType), BoolType)


  override def distance(left: Any, right: Any): Int = {
    if (eval(left, right).asInstanceOf[Boolean]) 0 else 1
  }
}


case class NotOperator[T: ClassTag]()(implicit strategy: NotComputable[T]) extends UnaryOperator[Boolean] {
  override def eval(expr: Any): Boolean = strategy.compute(expr.asInstanceOf[T])

  override def toString: String = "!"

  override def signature: Signature = Signature(
    List(scalaTypeToExprType(classTag[T].runtimeClass)), BoolType
  )
}

case class NegateOperator[T: ClassTag]()(implicit strategy: Negatable[T]) extends UnaryOperator[T] {
  override def eval(expr: Any): T =  strategy.negate(expr.asInstanceOf[T])

  override def toString: String = "-"

  override def signature: Signature = Signature(
    List(scalaTypeToExprType(classTag[T].runtimeClass)), scalaTypeToExprType(classTag[T].runtimeClass)
  )
}

case class AbsOperator[T: ClassTag]()(implicit strategy: Absolutable[T]) extends UnaryOperator[T] {
  override def eval(expr: Any): T =  strategy.abs(expr.asInstanceOf[T])

  override def toString: String = "abs"

  override def signature: Signature = Signature(
    List(scalaTypeToExprType(classTag[T].runtimeClass)), scalaTypeToExprType(classTag[T].runtimeClass)
  )
}

case class BoolToIntOperator[T: ClassTag]()(implicit strategy: BoolToIntConvertible[T]) extends UnaryOperator[Integer] {
  override def eval(expr: Any): Integer = strategy.convert(expr.asInstanceOf[T])

  override def toString: String = "bool2int"

  override def signature: Signature = Signature(
    List(scalaTypeToExprType(classTag[T].runtimeClass)),
    scalaTypeToExprType(classOf[Integer])
  )
}

---

File: ./components/Relational.scala
package com.beepboop.app.components

trait Equatable[T] extends Serializable{
  def equal(a: T, b: T): Boolean
}

object Equatable {
  implicit object IntIsEquatable extends Equatable[Integer] {
    override def equal(a: Integer, b: Integer): Boolean = a == b
  }

  implicit object BoolIsEquatable extends Equatable[Boolean] {
    override def equal(a: Boolean, b: Boolean): Boolean = a == b
  }

  implicit object ListIntIsEquatable extends Equatable[List[Integer]] {
    override def equal(a: List[Integer], b: List[Integer]): Boolean = a == b
  }

  implicit object SetIntIsEquatable extends Equatable[Set[Integer]] {
    override def equal(a: Set[Integer], b: Set[Integer]): Boolean = a == b
  }
}

trait NotEquatable[T] extends Serializable{
  def notEqual(a: T, b: T): Boolean
  def distance(a: T, b: T): Int
}

object NotEquatable {
  implicit object IntIsNotEquatable extends NotEquatable[Integer] {
    override def notEqual(a: Integer, b: Integer): Boolean = a != b
    override def distance(a: Integer, b: Integer): Int = {
      Math.abs(Math.abs(a - b) - 1)
    }
  }

  implicit object BoolIsNotEquatable extends NotEquatable[Boolean] {
    override def notEqual(a: Boolean, b: Boolean): Boolean = a != b
    override def distance(a: Boolean, b: Boolean): Int = if (a != b) 0 else 1
  }

  implicit object ListIntIsNotEquatable extends NotEquatable[List[Integer]] {
    override def notEqual(a: List[Integer], b: List[Integer]): Boolean = a != b
    override def distance(a: List[Integer], b: List[Integer]): Int = {
      if (a != b) 0 else 1
    }
  }

  implicit object SetIntIsNotEquatable extends NotEquatable[Set[Integer]] {
    override def notEqual(a: Set[Integer], b: Set[Integer]): Boolean = a != b
    override def distance(a: Set[Integer], b: Set[Integer]): Int = {
      val diffSize = (a diff b).size + (b diff a).size
      Math.abs(diffSize - 1)
    }
  }
}

trait Contains[L, R] extends Serializable{
  def contains(left: L, right: R): Boolean
  def distance(left: L, right: R): Int
}

implicit object ListIntContainsInt extends Contains[List[Integer], Integer] {
  override def contains(left: List[Integer], right: Integer): Boolean = left.contains(right)

  override def distance(left: List[Integer], right: Integer): Int = {
    if (left.isEmpty) return Int.MaxValue
    if (left.contains(right)) return 0
    left.map(x => (x - right).abs).min
  }
}

implicit object SetIntContainsInt extends Contains[Set[Int], Int] {
  override def contains(left: Set[Int], right: Int): Boolean = left.contains(right)

  override def distance(left: Set[Int], right: Int): Int = {
    if (left.isEmpty) return Int.MaxValue
    if (left.contains(right)) 0
    else left.map(x => (x - right).abs).min
  }
}

trait LessThan[T] extends Serializable{
  def less(a: T, b: T): Boolean
}

object LessThan {
  implicit object IntIsLessThan extends LessThan[Integer] {
    override def less(a: Integer, b: Integer): Boolean = a < b
  }
}

trait GreaterThan[T] extends Serializable{
  def greater(a: T, b: T): Boolean
}

object GreaterThan {
  implicit object IntIsGreaterThan extends GreaterThan[Integer] {
    override def greater(a: Integer, b: Integer): Boolean = a > b
  }
}

trait LessEqual[T] extends Serializable{
  def lessEqual(a: T, b: T): Boolean
}

object LessEqual {
  implicit object IntIsLessEqual extends LessEqual[Integer] {
    override def lessEqual(a: Integer, b: Integer): Boolean = a <= b
  }
}

trait GreaterEqual[T] extends Serializable{
  def greaterEqual(a: T, b: T): Boolean
}

object GreaterEqual {
  implicit object IntIsGreaterEqual extends GreaterEqual[Integer] {
    override def greaterEqual(a: Integer, b: Integer): Boolean = a >= b
  }
}

trait NotComputable[T] extends Serializable{
  def compute(a: T): Boolean
}

object NotComputable {
  implicit object BoolIsNotComputable extends NotComputable[Boolean] {
    override def compute(a: Boolean): Boolean = !a
  }
}

---

File: ./components/ComponentRegistry.scala
package com.beepboop.app.components

/* third party modules */
// intelij can mark this as non found, but it works

/* own modules */
import com.beepboop.app.components.Operator
import com.beepboop.app.components.Expression
import com.beepboop.app.components.SetIntContainsInt
import com.beepboop.app.components.StrEqExpression.StrEqFactory
import com.beepboop.app.dataprovider.DataProvider
import com.beepboop.app.logger.LogTrait
import org.yaml.snakeyaml.Yaml

import scala.jdk.CollectionConverters.*
import java.io.FileInputStream
import java.util.Map as JMap

sealed trait ExpressionType
case object IntType extends ExpressionType
case object BoolType extends ExpressionType
case object ListIntType extends ExpressionType
case object SetIntType extends ExpressionType
case object IteratorType extends ExpressionType
case object UnknownType extends ExpressionType
case object ListTaskType extends ExpressionType
case object MapIntToIntType extends ExpressionType
case object ListAnyType extends ExpressionType
case object ListRectType extends ExpressionType
case object StringType extends ExpressionType

case class Signature(inputs: List[ExpressionType], output: ExpressionType)


def scalaTypeToExprType(cls: Class[?]): ExpressionType = cls match {
  case c if c == classOf[java.lang.Integer] || c == java.lang.Integer.TYPE =>
    IntType

  case c if c == classOf[java.lang.String] =>
    StringType

  case c if c == classOf[java.lang.Boolean] || c == java.lang.Boolean.TYPE =>
    BoolType

  case c if c == classOf[List[Integer]] =>
    ListIntType

  case c if c == classOf[Set[Int]] || classOf[Set[?]].isAssignableFrom(c) =>
    SetIntType

  case c if c == classOf[List[Task]] =>
    ListTaskType

  case c if c == classOf[Map[Integer, Integer]] =>
    MapIntToIntType

  case c if c == classOf[List[Any]] =>
    ListAnyType

  case _ =>
    throw new Exception(s"Unsupported type: ${cls.getName}")
}


private def toScala(value: Any): Any = value match {
  case m: java.util.Map[_, _] =>
    m.asScala.view.mapValues(toScala).toMap
  case l: java.util.List[_] =>
    l.asScala.map(toScala).toList
  case other => other
}

object ComponentRegistry extends LogTrait {

  private val binaryOperators: List[BinaryOperator[?]] = List(
    /*
    // arithmetic
    new AddOperator[Integer],
    new SubOperator[Integer],
    new MulOperator[Integer],
    //new DivOperator[Integer],
    new ModOperator[Integer],
    */

    // relational
    new EqualOperator[Integer],
    new EqualOperator[Boolean],
    new EqualOperator[List[Integer]],
    new EqualOperator[Set[Integer]],

    new NotEqualOperator[Integer](),
    new NotEqualOperator[Boolean](),
    new NotEqualOperator[List[Integer]](),
    new NotEqualOperator[Set[Integer]](), // todo: rewrite

    new LessOperator[Integer],
    new GreaterOperator[Integer],
    new LessEqualOperator[Integer],
    new GreaterEqualOperator[Integer],

    new AndOperator[Boolean],
    new OrOperator[Boolean],
    new XorOperator[Boolean],
    new ImpliesOperator[Boolean],

    // new ContainsOperator[List[Integer], Integer],
    // new ContainsOperator[Set[Int], Int]
  )

  private val unaryOperators: List[UnaryOperator[?]] = List(
    new NotOperator[Boolean](),
    new NegateOperator[Integer](),
    new AbsOperator[Integer](),
    new BoolToIntOperator[Boolean]()
    // todo: add another unary operator
  )

  private val allVariablesFactories: List[Creatable] = DataProvider.getVariableCreatables

  private val allOperators: List[Operator[?]] = binaryOperators ++ unaryOperators

  private val allConstantFactories: List[Creatable] = List(
    Constant.asCreatable[Integer](() => scala.util.Random.nextInt(10)),
    Constant.asCreatable[Boolean](() => scala.util.Random.nextBoolean())
  )
  private val allArrayElementFactories: List[Creatable] = List(
    ArrayElement.asCreatable[Integer](),
    ArrayElement.asCreatable[Boolean](),
  )

  private val expressionFactories: List[Creatable] = List(
    SumExpression.IntListSumFactory,
    ForAllExpression.ForAllIntListFactory,
    CountExpression.IntListCountFactory,
    AllDifferentExpression.ListAllDifferentFactory,
    ExistsExpression.ExistsIntListFactory,
    MinimumExpression.ListMinimumFactory,
    MaximumExpression.ListMaximumFactory,
    GlobalCardinalityExpression.GlobalCardinalityFactory,
    DiffnExpression.DiffnFactory,
    ValuePrecedesChainExpression.ValuePrecedesChainFactory,
    StrEqExpression.StrEqFactory,
    //CumulativeExpression
    //LexicographicalExpression.asCreatable()
  )

  private def toScala(value: Any): Any = value match {
    case m: java.util.Map[_, _] =>
      m.asScala.view.mapValues(toScala).toMap
    case l: java.util.List[_] =>
      l.asScala.map(toScala).toList
    case other => other
  }

  private val configFile = "src/main/resources/expressions.yml"
  private lazy val creatablesConfig: Map[String, Double] = {
    val yaml = new Yaml()
    val input = new FileInputStream(configFile)
    try {
      val javaData = yaml.load[java.util.Map[String, Object]](input)

      def toDouble(obj: Object): Double = obj match {
        case d: java.lang.Double => d.doubleValue()
        case i: java.lang.Integer => i.doubleValue()
        case b: java.lang.Boolean => if (b) 1.0 else 0.0
        case _ => 0.0
      }

      javaData.asScala.toMap.map { case (k, v) =>
        k -> toDouble(v)
      }
    } finally {
      input.close()
    }
  }


  val creatables: List[Creatable] = (
    binaryOperators.map(op => BinaryExpression.asCreatable(op)) ++
      unaryOperators.map(op => UnaryExpression.asCreatable(op)) ++
      allConstantFactories ++
      allVariablesFactories ++
      expressionFactories ++
      allArrayElementFactories
    ).filter(c =>
    creatablesConfig.getOrElse(c.toString, 0.0) > 0.0
  )

  debug(s"creatables: $creatables")

  def getWeight(c: Creatable): Double = {
    creatablesConfig.getOrElse(c.toString, 1.0)
  }


  def findCreatablesReturning(outputType: ExpressionType): List[Creatable] = {
    creatables.filter(_.templateSignature.output == outputType)
  }



  def findOperatorReturning(outputType: ExpressionType): List[Operator[?]] = {
    allOperators.filter(_.signature.output == outputType)
  }

  def findOperatorsForInputs(inputTypes: List[ExpressionType]): List[Operator[?]] = {
    allOperators.filter(_.signature.inputs == inputTypes)
  }

  def findOperatorsWithSignature(sig: Signature): List[Operator[?]] = {
    allOperators.filter(_.signature == sig)
  }

}

---

File: ./components/Creatable.scala
package com.beepboop.app.components


class RandomVariableFactory(
                             val varType: ExpressionType,
                             val availableNames: List[String]
                           ) extends Creatable with AutoNamed {
  override def templateSignature: Signature = Signature(inputs = Nil, output = varType)

  override def create(children: List[Expression[?]]): Expression[?] = {
    require(children.isEmpty)
    if (availableNames.isEmpty) {
      throw new IllegalStateException(s"No variables of type $varType are available.")
    }
    val randomName = availableNames(scala.util.Random.nextInt(availableNames.length))
    createWithName(randomName)
  }

  override def ownerClass: Class[_] = Variable.getClass

  def createWithName(name: String): Expression[?] = {
    varType match {
      case IntType => Variable[Integer](name)
      case BoolType => Variable[Boolean](name)
      case ListIntType => Variable[List[Integer]](name)
    }
  }
}

---

File: ./components/Expression.scala
package com.beepboop.app.components

import com.beepboop.app.components.*
import com.beepboop.app.dataprovider.{DataProvider, VarNameGenerator}
import com.beepboop.app.logger.LogTrait
import com.beepboop.app.mutations.{ContextAwareCreatable, GenerationContext}
import com.beepboop.app.policy.{EnsureSpecificVarExists, Policy}
import com.beepboop.app.postprocessor.Postprocessor
import com.beepboop.app.utils.Implicits.integerNumeric

import java.lang.Integer.sum
import java.util


/* third party modules */
import scala.reflect.{ClassTag, classTag}

def stringWithSpaces(strings: String*): String = {
  strings.mkString(" ")
}

trait ScopeModifier {
  def getAdditionalPolicies: List[Policy]
}

trait ComposableExpression {
  def children: List[Expression[?]]
  def withNewChildren(newChildren: List[Expression[?]]): Expression[?]
}

trait OperatorContainer {
  def operator: Operator[?]
  def withNewOperator(newOp: Operator[?]): Expression[?]
}

trait Creatable {
  def templateSignature: Signature
  def create(children: List[Expression[?]]): Expression[?]
}

trait AutoNamed {
  protected def ownerClass: Class[_]
  override def toString: String = ownerClass.getSimpleName.stripSuffix("$")
}

abstract class Expression[ReturnT](implicit val ct: ClassTag[ReturnT]) extends LogTrait with Serializable {
  def toString: String
  def eval(context: Map[String, Any]): ReturnT
  def evalToString: String
  def signature: Signature
  def distance(context: Map[String, Any]): Int = {
    0
  }
}

case class Variable[ReturnT : ClassTag ](name: String) extends Expression[ReturnT] {
  override def toString: String = name
  override def evalToString: String = eval.toString
  override def signature: Signature = {
    val outputType = scalaTypeToExprType(classTag[ReturnT].runtimeClass)
    Signature(inputs = Nil, output = outputType)
  }
  override def eval(context: Map[String, Any]): ReturnT = {
    context.get(name) match {
      case Some(value) => value.asInstanceOf[ReturnT]
      case None => throw new NoSuchElementException(s"Variable '$name' not found in evaluation context.")
    }
  }
}


case class Constant[ReturnT : ClassTag](value: ReturnT) extends Expression[ReturnT] {
  override def toString: String = value match {
    case list: List[_] => list.mkString("[", ", ", "]")
    case arr: Array[_] => arr.mkString("[", ", ", "]")
    case _ => value.toString
  }
  override def eval(context: Map[String, Any]): ReturnT = value
  override def evalToString: String = value.toString
  override def signature: Signature = {
    val outputType = scalaTypeToExprType(classTag[ReturnT].runtimeClass)
    Signature(inputs = Nil, output = outputType)
  }
}

object Constant {
  def asCreatable[T: ClassTag](randomValueGenerator: () => T): Creatable = new Creatable with AutoNamed {
    override def templateSignature: Signature = {
      val outputType = scalaTypeToExprType(classTag[T].runtimeClass)
      Signature(inputs = Nil, output = outputType)
    }

    override def create(children: List[Expression[?]]): Expression[?] = {
      require(children.isEmpty, "Constant requires no children.")
      Constant(randomValueGenerator())
    }

    override def ownerClass: Class[_] = Constant.getClass
  }
}

case class ArrayElement[ReturnT : ClassTag](
                                           variable: Expression[List[ReturnT]],
                                           index: Expression[Integer]
                                           ) extends Expression[ReturnT] with ComposableExpression {
  override def children: List[Expression[?]] = List(variable, index)

  override def withNewChildren(newChildren: List[Expression[?]]): Expression[?] = {
    require(newChildren.length == 2, "ArrayElement requires exactly two children.")
    this.copy(variable = newChildren.head.asInstanceOf[Expression[List[ReturnT]]],
      index = newChildren(1).asInstanceOf[Expression[Integer]])
  }

  override def eval(context: Map[String, Any]): ReturnT = {
    variable.eval(context).apply(index.eval(context))
  }

  override def toString: String = s"${variable.toString}[${index.toString}]"
  override def evalToString: String = s"${variable.toString}[${index.evalToString}]"

  override def signature: Signature = {
    val listInputType = scalaTypeToExprType(classTag[List[ReturnT]].runtimeClass)
    val intInputType = scalaTypeToExprType(classTag[Integer].runtimeClass)
    val singleOutputType = scalaTypeToExprType(classTag[ReturnT].runtimeClass)
    Signature(inputs = List(listInputType,  intInputType), singleOutputType)
  }

}

object ArrayElement {
  def asCreatable[T: ClassTag](): Creatable = new Creatable with AutoNamed {
    override def templateSignature: Signature = {
      val listInputType = scalaTypeToExprType(classTag[List[T]].runtimeClass)
      val intInputType = scalaTypeToExprType(classTag[Integer].runtimeClass)
      val singleOutputType = scalaTypeToExprType(classTag[T].runtimeClass)
      Signature(inputs = List(listInputType, intInputType), output = singleOutputType)
    }

    override def create(children: List[Expression[?]]): Expression[T] = {
      require(children.length == 2, "ArrayElement requires two children.")
      ArrayElement[T](children(0).asInstanceOf[Expression[List[T]]], children(1).asInstanceOf[Expression[Integer]])

    }

    override def ownerClass: Class[_] = ArrayElement.getClass
  }
}

case class IteratorDef[IterT : ClassTag](
                              variableName: String,
                              collection: Expression[List[IterT]]
                            ) extends Expression[(String, List[IterT])] with ComposableExpression {
  override def children: List[Expression[?]] = List(collection)

  override def withNewChildren(newChildren: List[Expression[?]]): Expression[?] = {
    require(newChildren.length == 1, "IteratorDef requires exactly one child (the collection).")
    this.copy(collection = newChildren.head.asInstanceOf[Expression[List[IterT]]])
  }

  override def eval(context: Map[String, Any]): (String, List[IterT]) = {
    (variableName, collection.eval(context))
  }

  override def toString: String = s"$variableName in $collection"
  override def evalToString: String = s"${variableName} in ${collection.evalToString}"

  override def signature: Signature = {
    Signature(inputs = Nil, output = UnknownType)
  }

}

case class BinaryExpression[ReturnT : ClassTag](
                                               left: Expression[?],
                                               operator: BinaryOperator[ReturnT],
                                               right: Expression[?]
                                             ) extends Expression[ReturnT]
                                              with OperatorContainer
                                              with ComposableExpression
{

  override def withNewOperator(newOp: Operator[?]): Expression[?] = newOp match {
    case op: BinaryOperator[?] =>
      this.copy(operator = newOp.asInstanceOf[BinaryOperator[ReturnT]])
    case _ =>
      throw new IllegalArgumentException(s"Cannot replace operator in BinaryExpression with non-binary operator ${newOp}")
  }

  override def children: List[Expression[?]] = List(left,right)

  override def withNewChildren(newChildren: List[Expression[?]]): Expression[?] = {
    require(newChildren.length == 2, "BinaryExpression requires exactly two children for reconstruction")

    require(
      newChildren.head.signature.output == operator.signature.inputs.head,
      s"Left child output data type doesn't match required operator signature input, (new)${newChildren.head.signature.output} != ${operator.signature.inputs.head} for ${this.operator.toString} [${this.toString}] (${newChildren}) | withNewChildren"
    )

    require(
      newChildren(1).signature.output == operator.signature.inputs(1),
      s"Right child output data type doesn't match required operator signature input, (new)${newChildren(1).signature.output} != ${operator.signature.inputs(1)} for ${this.operator.toString} " +
        s" [${this.toString}] (${newChildren}) | withNewChildren"
    )
    this.copy(left = newChildren.head, right = newChildren(1))
  }

  override def toString: String = stringWithSpaces("(", left.toString, operator.toString, right.toString, ")")
  override def evalToString: String = stringWithSpaces("(", left.evalToString, operator.toString, right.evalToString, ")")

  override def eval(context: Map[String, Any]): ReturnT = {
    val result = operator.eval(left.eval(context), right.eval(context))
    debug(s"result of eval for ${this.toString} is : ${left.eval(context).toString} ${operator.toString} ${right.eval(context).toString} = $result")
    result
  }
  override def signature: Signature = operator.signature

  override def distance(context: Map[String, Any]): Int = {
    operator match {
      case _: AndOperator[_] =>
        left.distance(context) + right.distance(context)
      case _: OrOperator[_] =>
        Math.min(left.distance(context), right.distance(context))
      case _: ImpliesOperator[_] =>
        if (left.eval(context).asInstanceOf[Boolean]) right.distance(context) else 0
      case _ =>
        operator.distance(left.eval(context), right.eval(context))
    }
  }
}

object BinaryExpression {
  def asCreatable[T](op: BinaryOperator[T]): Creatable = new Creatable with AutoNamed {
    override def templateSignature: Signature = op.signature
    override def create(children: List[Expression[?]]): Expression[T] = {
      require(children.length == 2)
      implicit val tag: ClassTag[T] = op.ct

      require(
        children(0).signature.output == op.signature.inputs(0),
        s"Left child output data type doesn't match required operator signature input, ${children(0).signature.output} != ${op.signature.inputs(0)} for ${op.toString}"
      )
      require(
        children(1).signature.output == op.signature.inputs(1),
        s"Right child output data type doesn't match required operator signature input, ${children(1).signature.output} != ${op.signature.inputs(1)} for ${op.toString}"
      )
      BinaryExpression(children(0).asInstanceOf[Expression[T]] , op, children(1).asInstanceOf[Expression[T]])
    }

    override def ownerClass: Class[_] = BinaryExpression.getClass
  }
}

case class UnaryExpression[ReturnT : ClassTag](
                                        expr: Expression[?],
                                        operator: UnaryOperator[ReturnT]
                                      ) extends Expression[ReturnT]
                                      with OperatorContainer
                                      with ComposableExpression {
  override def withNewOperator(newOp: Operator[?]): Expression[?] = newOp match {
    case op: UnaryOperator[ReturnT] =>
      this.copy(operator = newOp.asInstanceOf[UnaryOperator[ReturnT]])
    case _ =>
      throw new IllegalArgumentException(s"Cannot replace operator in BinaryExpression with non-binary operator ${newOp}")
  }

  override def eval(context: Map[String, Any]): ReturnT = operator.eval(expr.eval(context))

  override def children: List[Expression[?]]  = List(expr)

  override def withNewChildren(newChildren: List[Expression[?]]): Expression[?] = {
    require(newChildren.length == 1, "UnaryExpression requires exactly one children for reconstruction")
    this.copy(expr = newChildren(0))
  }

  override def toString: String =  operator.toString + "(" + expr.toString + ")"
  override def evalToString: String = operator.toString + expr.evalToString

  override def signature: Signature = operator.signature

}

object UnaryExpression {
  def asCreatable[T](op: UnaryOperator[T]): Creatable = new Creatable with AutoNamed {
    override def templateSignature: Signature = op.signature
    override def create(children: List[Expression[?]]): Expression[T] = {
      implicit val tag: ClassTag[T] = op.ct
      require(children.length == 1)
      require(children(0).signature.output == op.signature.inputs(0), s"Child output data type doesn't match required operator signature input, ${children(0).signature.output} != ${op.signature.inputs(0)} for ${op.toString}")
      UnaryExpression(children(0), op)
    }
    override def ownerClass: Class[_] = UnaryExpression.getClass
  }
}

case class SumExpression[ReturnT : Numeric : ClassTag](
                                              expr: Expression[List[ReturnT]],
                                            ) extends Expression[ReturnT]
                                            with ComposableExpression {

  override def children: List[Expression[?]]  = List(expr)

  override def withNewChildren(newChildren: List[Expression[?]]): Expression[?] = {
    require(newChildren.length == 1, "SumExpression requires exactly one children for reconstruction")
    this.copy(expr = newChildren.head.asInstanceOf[Expression[List[ReturnT]]])
  }

  override def toString: String =  "sum(" + expr.toString + ")"
  override def evalToString: String =  "sum(" + expr.evalToString + ")"

  override def eval(context: Map[String, Any]): ReturnT = {
    val numeric = implicitly[Numeric[ReturnT]]
    var listToSum = expr.eval(context)
    listToSum.foldLeft(numeric.zero) { (accumulator, element) =>
      numeric.plus(accumulator, element)
    }
  }
  override def signature: Signature = {
    val listInputType = scalaTypeToExprType(classTag[List[ReturnT]].runtimeClass)
    val singleOutputType = scalaTypeToExprType(classTag[ReturnT].runtimeClass)
    Signature(inputs = List(listInputType), output = singleOutputType)
  }

}

object SumExpression {
  object IntListSumFactory extends Creatable with AutoNamed {
    override def templateSignature: Signature = Signature(inputs = List(ListIntType), output = IntType)

    override def create(children: List[Expression[?]]): Expression[?] = {
      require(children.length == 1, "SumExpression.create requires one child.")
      val child = children.head.asInstanceOf[Expression[List[Integer]]]
      SumExpression[Integer](child)
    }

    override protected def ownerClass: Class[_] = SumExpression.getClass
  }
}

case class CountExpression(
                            expr: Expression[? <: List[Any]]
                          ) extends Expression[Integer]
  with ComposableExpression {

  override def children: List[Expression[?]] = List(expr)

  override def withNewChildren(newChildren: List[Expression[?]]): Expression[?] = {
    require(newChildren.length == 1, "CountExpression requires one child.")
    this.copy(expr = newChildren.head.asInstanceOf[Expression[List[?]]])
  }

  override def toString: String = s"count(${expr.toString})"

  override def evalToString: String = s"count(${expr.evalToString})"

  override def eval(context: Map[String, Any]): Integer = {
    val listToCount = expr.eval(context)
    listToCount.length
  }

  override def signature: Signature = {
    val listInputType = scalaTypeToExprType(classTag[List[Any]].runtimeClass)
    val singleOutputType = scalaTypeToExprType(classTag[Integer].runtimeClass)

    Signature(inputs = List(listInputType), output = singleOutputType)
  }
}

object CountExpression {
  object IntListCountFactory extends Creatable with AutoNamed {
    override def templateSignature: Signature = {
      Signature(inputs = List(ListIntType), output = IntType)
    }

    override def create(children: List[Expression[?]]): Expression[?] = {
      require(children.length == 1, "CountExpression.create requires one child (the list expression).")
      val child = children.head.asInstanceOf[Expression[List[Any]]]
      CountExpression(child)
    }
    override protected def ownerClass: Class[_] = CountExpression.getClass
  }
}

case class ForAllExpression[IterT](
                            iteratorDef: IteratorDef[IterT], // This is now an Expression
                            body: Expression[Boolean]
                          ) extends Expression[Boolean]
                          with ComposableExpression
                          with ScopeModifier {

  override def children: List[Expression[?]] = List(iteratorDef, body)
  override def withNewChildren(newChildren: List[Expression[?]]): Expression[?] = {
    require(newChildren.length == 2)
    this.copy(
      iteratorDef = newChildren(0).asInstanceOf[IteratorDef[IterT]],
      body = newChildren(1).asInstanceOf[Expression[Boolean]]
    )
  }

  override def getAdditionalPolicies: List[Policy] = {
    List(EnsureSpecificVarExists(iteratorDef.variableName))
  }

  override def toString: String = s"forall($iteratorDef)($body)"
  override def evalToString: String = s"forall($iteratorDef)($body)"

  override def eval(context: Map[String, Any]): Boolean = {
    val (variableName, itemsToIterate) = iteratorDef.eval(context)
    itemsToIterate.forall { item =>
      body.eval(context.+(variableName -> item))
    }
  }

  override def distance(context: Map[String, Any]): Int = {
    val (variableName, itemsToIterate) = iteratorDef.eval(context)
    itemsToIterate.map(item => body.distance(context.+(variableName -> item))).sum
  }

  override def signature: Signature = Signature(inputs = List(ListIntType, BoolType), output = BoolType)
}


object ForAllExpression {
  object ForAllIntListFactory extends Creatable with AutoNamed with ContextAwareCreatable {

    override def templateSignature: Signature = Signature(List(ListIntType, BoolType), BoolType)

    // Standard create is not used by the generator anymore for this factory
    override def create(children: List[Expression[?]]): Expression[?] =
      throw new UnsupportedOperationException("This factory requires context-aware generation.")

    override def generateExpression(
                                     ctx: GenerationContext,
                                     recurse: (ExpressionType, GenerationContext) => Option[Expression[?]]
                                   ): Option[Expression[?]] = {

      val collectionOpt = recurse(ListIntType, ctx).map(_.asInstanceOf[Expression[List[Integer]]])
      if (collectionOpt.isEmpty) return None

      val varName = VarNameGenerator.generateUniqueName("f")

      val newCtx = ctx.withVariable(varName, IntType)

      val bodyOpt = recurse(BoolType, newCtx).map(_.asInstanceOf[Expression[Boolean]])

      if (bodyOpt.isEmpty) return None

      val iterator = IteratorDef(varName, collectionOpt.get)
      Some(ForAllExpression(iterator, bodyOpt.get))
    }

    override def ownerClass: Class[_] = ForAllExpression.getClass
  }
}



case class ExistsExpression[IterT](
                                    iteratorDef: IteratorDef[IterT],
                                    body: Expression[Boolean]
                                  ) extends Expression[Boolean] with ComposableExpression {


  override def children: List[Expression[?]] = List(iteratorDef, body)


  override def withNewChildren(newChildren: List[Expression[?]]): Expression[?] = {
    require(newChildren.length == 2, "ExistsExpression requires two children.")
    this.copy(
      iteratorDef = newChildren(0).asInstanceOf[IteratorDef[IterT]],
      body = newChildren(1).asInstanceOf[Expression[Boolean]]
    )
  }


  override def toString: String = s"exists($iteratorDef)($body)"

  override def evalToString: String = s"exists($iteratorDef)($body)"


  override def eval(context: Map[String, Any]): Boolean = {
    val (variableName, itemsToIterate) = iteratorDef.eval(context)


    itemsToIterate.exists { item =>
      body.eval(context.+(variableName -> item))
    }
  }

  override def distance(context: Map[String, Any]): Int = {
    val (variableName, itemsToIterate) = iteratorDef.eval(context)
    if (itemsToIterate.isEmpty) 1 else itemsToIterate.map(item => body.distance(context.+(variableName -> item))).min
  }

  override def signature: Signature = Signature(inputs = List(ListAnyType, BoolType), output = BoolType)
}

/* todo: based on forall add adding to context and globally unique name */
object ExistsExpression {
  object ExistsIntListFactory extends Creatable with AutoNamed {

    override def templateSignature: Signature = Signature(inputs = List(ListAnyType, BoolType), output = BoolType)

    override def create(children: List[Expression[?]]): Expression[?] = {
      require(children.length == 2, "ExistsExpression.create requires two children.")

      val collectionExpr = children(0).asInstanceOf[Expression[List[Integer]]]
      val bodyExpr = children(1).asInstanceOf[Expression[Boolean]]

      val iterator = IteratorDef("j", collectionExpr)

      ExistsExpression(iterator, bodyExpr)
    }
    override def ownerClass: Class[_] = ForAllExpression.getClass
  }
}



case class AllDifferentExpression(
                                   expr: Expression[? <: List[?]]
                                 ) extends Expression[Boolean]
  with ComposableExpression {

  override def children: List[Expression[?]] = List(expr)

  override def withNewChildren(newChildren: List[Expression[?]]): Expression[?] = {
    require(newChildren.length == 1, "AllDifferentExpression requires one child.")
    this.copy(expr = newChildren.head.asInstanceOf[Expression[List[?]]])
  }

  override def toString: String = s"alldifferent(${expr.toString})"

  override def evalToString: String = s"alldifferent(${expr.evalToString})"

  override def eval(context: Map[String, Any]): Boolean = {
    val list = expr.eval(context)
    list.nonEmpty && (list.size == list.toSet.size)
  }

  override def distance(context: Map[String, Any]): Int = {
    val list = expr.eval(context)
    if (list.isEmpty) {
      0
    } else {
      val counts = list.groupBy(identity).view.mapValues(_.size).toMap
      counts.values.map(count => if (count > 1) count - 1 else 0).sum
    }
  }

  override def signature: Signature = {
    val listInputType = scalaTypeToExprType(classTag[List[?]].runtimeClass)
    Signature(inputs = List(listInputType), output = BoolType)
  }
}

object AllDifferentExpression {
  object ListAllDifferentFactory extends Creatable with AutoNamed {
    override def templateSignature: Signature = Signature(inputs = List(ListIntType), output = BoolType)

    override def create(children: List[Expression[?]]): Expression[?] = {
      require(children.length == 1, "AllDifferentExpression.create requires one child.")

      val child = children.head.asInstanceOf[Expression[List[?]]]
      AllDifferentExpression(child)
    }
    override def ownerClass: Class[_] = AllDifferentExpression.getClass
  }
}

case class LexicographicalExpression[T : Ordering : ClassTag](
                                                               leftExpr: Expression[List[T]],
                                                               operator: BinaryOperator[Boolean],
                                                               rightExpr: Expression[List[T]]
                                                             ) extends Expression[Boolean]
  with OperatorContainer
  with ComposableExpression {

  override def withNewOperator(newOp: Operator[?]): Expression[?] = newOp match {
    case op: BinaryOperator[Boolean] =>
      this.copy(operator = newOp.asInstanceOf[BinaryOperator[Boolean]])
    case _ =>
      throw new IllegalArgumentException(s"Cannot replace operator in LexicographicalExpression with non-boolean binary operator ${newOp}")
  }

  override def children: List[Expression[?]] = List(leftExpr, rightExpr)

  override def withNewChildren(newChildren: List[Expression[?]]): Expression[?] = {
    require(newChildren.length == 2, "LexicographicalExpression requires exactly two children for reconstruction")
    this.copy(
      leftExpr = newChildren(0).asInstanceOf[Expression[List[T]]],
      rightExpr = newChildren(1).asInstanceOf[Expression[List[T]]]
    )
  }


  override def toString: String = {
    val leftStr = leftExpr.toString
    val rightStr = rightExpr.toString

    operator.toString match {
      case "<" => s"lex_less($leftStr, $rightStr)"
      case "<=" => s"lex_leq($leftStr, $rightStr)"
      case ">" => s"lex_greater($leftStr, $rightStr)"
      case ">=" => s"lex_greatereq($leftStr, $rightStr)"
      case "="  => s"$leftStr = $rightStr"
      case _ => throw new UnsupportedOperationException(s"Unsupported Lexicographical operator for export: ${operator.toString}")
    }
  }


  override def evalToString: String = {
    val leftStr = leftExpr.evalToString
    val rightStr = rightExpr.evalToString

    operator.toString match {
      case "<" => s"lex_less($leftStr, $rightStr)"
      case "<=" => s"lex_leq($leftStr, $rightStr)"
      case ">" => s"lex_greater($leftStr, $rightStr)"
      case ">=" => s"lex_greatereq($leftStr, $rightStr)"
      case "="  => s"$leftStr = $rightStr"
      case _ => throw new UnsupportedOperationException(s"Unsupported Lexicographical operator: ${operator.toString}")
    }
  }

  override def eval(context: Map[String, Any]): Boolean = {
    val leftList = leftExpr.eval(context)
    val rightList = rightExpr.eval(context)

    implicit val ordering: Ordering[List[T]] = Ordering.Implicits.seqOrdering
    val res = ordering.compare(leftList, rightList)

    operator match {
      case _: LessOperator[_] => res < 0
      case _: LessEqualOperator[_] => res <= 0
      case _: GreaterOperator[_] => res > 0
      case _: GreaterEqualOperator[_] => res >= 0
      case _: EqualOperator[_] => res == 0
      case _: NotEqualOperator[_] => res != 0
      case _ => false
    }
  }

  override def distance(context: Map[String, Any]): Int = {
    if (eval(context)) return 0
    val leftList = leftExpr.eval(context)
    val rightList = rightExpr.eval(context)

    val pairs = leftList.zip(rightList)
    val idx = pairs.indexWhere { case (a, b) => a != b }

    if (idx == -1) {
      if (leftList.length != rightList.length) 1 else 0
    } else {
      val a = leftList(idx)
      val b = rightList(idx)
      operator.distance(a, b)
    }
  }

  override def signature: Signature = {
    val listInputType = scalaTypeToExprType(classTag[List[T]].runtimeClass)
    Signature(inputs = List(listInputType, listInputType), output = BoolType)
  }
}

object LexicographicalExpression {
  def asCreatable(op: BinaryOperator[Boolean]): Creatable = new Creatable with AutoNamed {
    override def templateSignature: Signature = op.signature
    override def create(children: List[Expression[?]]): Expression[?] = {
      require(children.length == 2, "LexicographicalExpression.create requires two children.")

      val left = children(0).asInstanceOf[Expression[List[Integer]]]
      val right = children(1).asInstanceOf[Expression[List[Integer]]]


      LexicographicalExpression[Integer](left, op, right)
    }

    override def ownerClass: Class[_] = LexicographicalExpression.getClass

  }
}


case class MinimumExpression[ReturnT : Numeric : ClassTag](
                                                            elements: Expression[List[ReturnT]]
                                                          ) extends Expression[ReturnT]
  with ComposableExpression {

  override def children: List[Expression[?]] = List(elements)

  override def withNewChildren(newChildren: List[Expression[?]]): Expression[?] = {
    require(newChildren.length == 1, "MinimumExpression requires one child.")
    this.copy(elements = newChildren.head.asInstanceOf[Expression[List[ReturnT]]])
  }
  override def toString: String = s"min(${elements.toString})"

  override def evalToString: String = s"min(${elements.evalToString})"

  override def eval(context: Map[String, Any]): ReturnT = {

    val evaluatedList: List[ReturnT] = elements.eval(context)

    val numeric = implicitly[Numeric[ReturnT]]
    evaluatedList.min(numeric)
  }

  override def signature: Signature = {
    val listInputType = scalaTypeToExprType(classTag[List[ReturnT]].runtimeClass)
    val outputType = scalaTypeToExprType(classTag[ReturnT].runtimeClass)
    Signature(inputs = List(listInputType), output = outputType)
  }
}


object MinimumExpression {
  object ListMinimumFactory extends Creatable with AutoNamed {
    override def templateSignature: Signature = Signature(inputs = List(ListIntType), output = IntType)

    override def create(children: List[Expression[?]]): Expression[?] = {
      require(children.length == 1, "MinimumExpression.create requires one child.")

      val child = children.head.asInstanceOf[Expression[List[Integer]]]
      MinimumExpression[Integer](child)
    }
    override def ownerClass: Class[_] = MinimumExpression.getClass
  }

}

case class MaximumExpression[ReturnT : Numeric : ClassTag](
                                                            elements: Expression[List[ReturnT]]
                                                          ) extends Expression[ReturnT]
  with ComposableExpression {

  override def children: List[Expression[?]] = List(elements)

  override def withNewChildren(newChildren: List[Expression[?]]): Expression[?] = {
    require(newChildren.length == 1, "MaximumExpression requires one child.")
    this.copy(elements = newChildren.head.asInstanceOf[Expression[List[Integer]]])
  }

  override def toString: String = s"max(${elements.toString})"

  override def evalToString: String = s"max(${elements.evalToString})"

  override def eval(context: Map[String, Any]): ReturnT = {

    val evaluatedList: List[ReturnT] = elements.eval(context)
    val numeric = implicitly[Numeric[ReturnT]]

    evaluatedList.max(numeric)
  }

  override def signature: Signature = {
    val listInputType = scalaTypeToExprType(classTag[List[ReturnT]].runtimeClass)
    val outputType = scalaTypeToExprType(classTag[ReturnT].runtimeClass)
    Signature(inputs = List(listInputType), output = outputType)
  }
}

object MaximumExpression {
  object ListMaximumFactory extends Creatable with AutoNamed {
    override def templateSignature: Signature = Signature(inputs = List(ListIntType), output = IntType)

    override def create(children: List[Expression[?]]): Expression[?] = {
      require(children.length == 1, "MaximumExpression.create requires one child.")

      val child = children.head.asInstanceOf[Expression[List[Integer]]]
      MaximumExpression[Integer](child)
    }
    override def ownerClass: Class[_] = MaximumExpression.getClass
  }
}


case class Task(
                 start: Expression[Integer],
                 duration: Expression[Integer],
                 demand: Expression[Integer]
               ) {

  override def toString: String =
    s"Task(${start.toString}, ${duration.toString}, ${demand.toString})"

  def evalToString: String =
    s"Task(${start.evalToString}, ${duration.evalToString}, ${demand.evalToString})"
}


case class CumulativeExpression(
                                 tasks: Expression[List[Task]],
                                 operator: BinaryOperator[Boolean],
                                 limit: Expression[Integer]
                               ) extends Expression[Boolean]
  with OperatorContainer
  with ComposableExpression {

  override def withNewOperator(newOp: Operator[?]): Expression[?] = newOp match {
    case op: BinaryOperator[Boolean] =>
      this.copy(operator = newOp.asInstanceOf[BinaryOperator[Boolean]])
    case _ =>
      throw new IllegalArgumentException(s"Cannot replace operator in CumulativeExpression with non-binary operator ${newOp}")
  }

  override def children: List[Expression[?]] = List(tasks, limit)

  override def withNewChildren(newChildren: List[Expression[?]]): Expression[?] = {
    require(newChildren.length == 2, "CumulativeExpression requires two children.")
    this.copy(
      tasks = newChildren(0).asInstanceOf[Expression[List[Task]]],
      limit = newChildren(1).asInstanceOf[Expression[Integer]]
    )
  }

  override def toString: String =
    s"cumulative(${tasks.toString}, ${operator.toString}, ${limit.toString})"

  override def evalToString: String =
    s"cumulative(${tasks.evalToString}, ${operator.toString}, ${limit.evalToString})"


  override def eval(context: Map[String, Any]): Boolean = {
    val taskList = tasks.eval(context)
    val cap = limit.eval(context).intValue()

    if (taskList.isEmpty) return true

    val evaluatedTasks = taskList.map { task =>
      (
        task.start.eval(context).intValue(),
        task.duration.eval(context).intValue(),
        task.demand.eval(context).intValue()
      )
    }

    val s = evaluatedTasks.map(_._1)

    val minStart: Int = s.min
    val maxEnd: Int = evaluatedTasks.map { case (start, duration, _) => start + duration }.max

    (minStart until maxEnd).forall { time =>
      val currentLoad = evaluatedTasks.filter { case (start, duration, _) =>
        time >= start && time < start + duration
      }.map { case (_, _, demand) => demand }.sum


      operator.eval(currentLoad, cap)
    }
  }


  override def distance(context: Map[String, Any]): Int = {

    val taskList = tasks.eval(context)
    val cap = limit.eval(context).intValue()

    if (taskList.isEmpty) return 0

    val evaluatedTasks = taskList.map { task =>
      (
        task.start.eval(context).intValue(),
        task.duration.eval(context).intValue(),
        task.demand.eval(context).intValue()
      )
    }

    val s = evaluatedTasks.map(_._1)
    val minStart: Int = s.min
    val maxEnd: Int = evaluatedTasks.map { case (start, duration, _) => start + duration }.max


    (minStart until maxEnd).map { time =>
      val currentLoad = evaluatedTasks.filter { case (start, duration, _) =>
        time >= start && time < start + duration
      }.map { case (_, _, demand) => demand }.sum

      operator.distance(currentLoad, cap)
    }.sum
  }

  override def signature: Signature = {

    Signature(
      inputs = List(ListTaskType, IntType),
      output = BoolType
    )
  }
}

object CumulativeExpression {
  def asCreatable(op: BinaryOperator[Boolean]): Creatable = new Creatable with AutoNamed {
    override def templateSignature: Signature =
      Signature(
        inputs = List(ListTaskType, IntType),
        output = BoolType
      )

    override def create(children: List[Expression[?]]): Expression[?] = {
      require(children.length == 2, "CumulativeExpression.create requires two children (Task list, limit).")

      val tasksExpr = children(0).asInstanceOf[Expression[List[Task]]]
      val limitExpr = children(1).asInstanceOf[Expression[Integer]]


      CumulativeExpression(tasksExpr, op, limitExpr)
    }
    override def ownerClass: Class[_] = CumulativeExpression.getClass
  }
}


case class GlobalCardinalityExpression(
                                        variablesExpr: Expression[List[Integer]],
                                        expectedCountsExpr: Expression[Map[Integer, Integer]]
                                      ) extends Expression[Boolean]
  with ComposableExpression {

  override def children: List[Expression[?]] = List(variablesExpr, expectedCountsExpr)

  override def withNewChildren(newChildren: List[Expression[?]]): Expression[?] = {
    require(newChildren.length == 2, "GlobalCardinalityExpression requires two children.")
    this.copy(
      variablesExpr = newChildren(0).asInstanceOf[Expression[List[Integer]]],
      expectedCountsExpr = newChildren(1).asInstanceOf[Expression[Map[Integer, Integer]]]
    )
  }

  override def toString: String =
    s"global_cardinality(${variablesExpr.toString}, ${expectedCountsExpr.toString})"

  override def evalToString: String =
    s"global_cardinality(${variablesExpr.evalToString}, ${expectedCountsExpr.evalToString})"


  override def eval(context: Map[String, Any]): Boolean = {
    val list = variablesExpr.eval(context)
    val requiredCounts = expectedCountsExpr.eval(context)


    val actualFrequencies: Map[Integer, Int] =
      list.filter(requiredCounts.contains).groupBy(identity).view.mapValues(_.size).toMap


    requiredCounts.forall { case (value, requiredCount) =>
      val actualCount = actualFrequencies.getOrElse(value, 0)

      actualCount == requiredCount.intValue()
    }
  }

  override def distance(context: Map[String, Any]): Int = {
    val list = variablesExpr.eval(context)
    val requiredCounts = expectedCountsExpr.eval(context)

    val actualFrequencies: Map[Integer, Int] =
      list.filter(requiredCounts.contains).groupBy(identity).view.mapValues(_.size).toMap

    requiredCounts.map { case (value, requiredCount) =>
      val actualCount = actualFrequencies.getOrElse(value, 0)

      val reqCountInt = requiredCount.intValue()

      Math.abs(actualCount - reqCountInt)
    }.sum
  }

  override def signature: Signature = {

    Signature(
      inputs = List(ListIntType, MapIntToIntType),
      output = BoolType
    )
  }
}

object GlobalCardinalityExpression {
  object GlobalCardinalityFactory extends Creatable with AutoNamed {
    override def templateSignature: Signature =
      Signature(
        inputs = List(ListAnyType, MapIntToIntType),
        output = BoolType
      )

    override def create(children: List[Expression[?]]): Expression[?] = {
      require(children.length == 2, "GlobalCardinalityExpression.create requires two children.")

      val listExpr = children(0).asInstanceOf[Expression[List[Integer]]]
      val valuesExpr = children(1).asInstanceOf[Expression[Map[Integer, Integer]]]


      GlobalCardinalityExpression(listExpr, valuesExpr)
    }

    override def ownerClass: Class[_] = GlobalCardinalityExpression.getClass
  }
}


case class DiffnExpression(
                            x: Expression[List[Integer]],
                            y: Expression[List[Integer]],
                            dx: Expression[List[Integer]],
                            dy: Expression[List[Integer]]
                          ) extends Expression[Boolean]
  with ComposableExpression {

  override def children: List[Expression[?]] = List(x, y, dx, dy)

  override def withNewChildren(newChildren: List[Expression[?]]): Expression[?] = {
    require(newChildren.length == 4, "DiffnExpression requires exactly four children (x, y, dx, dy) for reconstruction")


    DiffnExpression(
      newChildren(0).asInstanceOf[Expression[List[Integer]]],
      newChildren(1).asInstanceOf[Expression[List[Integer]]],
      newChildren(2).asInstanceOf[Expression[List[Integer]]],
      newChildren(3).asInstanceOf[Expression[List[Integer]]]
    )
  }

  override def eval(context: Map[String, Any]): Boolean = {
    val xVal = x.eval(context).map(_.intValue())
    val yVal = y.eval(context).map(_.intValue())
    val dxVal = dx.eval(context).map(_.intValue())
    val dyVal = dy.eval(context).map(_.intValue())

    val n = xVal.size
    require(yVal.size == n && dxVal.size == n && dyVal.size == n, "All input arrays for diffn must have the same length")

    for (i <- 0 until n; j <- (i + 1) until n) {
      if (rectanglesOverlap(
        xVal(i), yVal(i), dxVal(i), dyVal(i),
        xVal(j), yVal(j), dxVal(j), dyVal(j)
      )) {
        return false
      }
    }
    true
  }

  override def distance(context: Map[String, Any]): Int = {
    val xVal = x.eval(context)
    val yVal = y.eval(context)
    val dxVal = dx.eval(context)
    val dyVal = dy.eval(context)

    val n = xVal.size
    var totalOverlapArea = 0

    for (i <- 0 until n; j <- (i + 1) until n) {
      totalOverlapArea += intersectionArea(
        xVal(i), yVal(i), dxVal(i), dyVal(i),
        xVal(j), yVal(j), dxVal(j), dyVal(j)
      )
    }

    totalOverlapArea
  }


  private def rectanglesOverlap(x1: Int, y1: Int, w1: Int, h1: Int,
                                x2: Int, y2: Int, w2: Int, h2: Int): Boolean = {
    if (x1 + w1 <= x2 || x2 + w2 <= x1) return false
    if (y1 + h1 <= y2 || y2 + h2 <= y1) return false

    true
  }

  private def intersectionArea(x1: Int, y1: Int, w1: Int, h1: Int,
                               x2: Int, y2: Int, w2: Int, h2: Int): Int = {
    val xOverlap = Math.max(0, Math.min(x1 + w1, x2 + w2) - Math.max(x1, x2))
    val yOverlap = Math.max(0, Math.min(y1 + h1, y2 + h2) - Math.max(y1, y2))

    xOverlap * yOverlap
  }

  override def toString: String = stringWithSpaces("diffn(", x.toString, ",", y.toString, ",", dx.toString, ",", dy.toString, ")")

  override def evalToString: String = stringWithSpaces("diffn(", x.evalToString, ",", y.evalToString, ",", dx.evalToString, ",", dy.evalToString, ")")

  override def signature: Signature =
    val outputType = scalaTypeToExprType(classTag[Boolean].runtimeClass)
    Signature(
    inputs = List(
      x.signature.output,
      y.signature.output,
      dx.signature.output,
      dy.signature.output
    ),
    output = outputType
  )

}


object DiffnExpression {
  object DiffnFactory extends Creatable with AutoNamed {

    override def templateSignature: Signature = {
      Signature(
        inputs = List(ListIntType, ListIntType, ListIntType, ListIntType),
        output = BoolType
      )
    }

    override def create(children: List[Expression[?]]): Expression[?] = {
      require(children.length == 4, "DiffnExpression.create requires exactly four children (x, y, dx, dy).")

      DiffnExpression(
        children(0).asInstanceOf[Expression[List[Integer]]],
        children(1).asInstanceOf[Expression[List[Integer]]],
        children(2).asInstanceOf[Expression[List[Integer]]],
        children(3).asInstanceOf[Expression[List[Integer]]]
      )
    }

    override protected def ownerClass: Class[_] = DiffnExpression.getClass
  }
}



case class ValuePrecedesChainExpression(
                                         variablesExpr: Expression[List[Integer]],
                                         valuesToPrecedeExpr: Expression[List[Integer]]
                                       ) extends Expression[Boolean]
  with ComposableExpression {

  override def children: List[Expression[?]] = List(variablesExpr, valuesToPrecedeExpr)

  override def withNewChildren(newChildren: List[Expression[?]]): Expression[?] = {
    require(newChildren.length == 2, "ValuePrecedesChainExpression requires two children.")
    this.copy(
      variablesExpr = newChildren(0).asInstanceOf[Expression[List[Integer]]],
      valuesToPrecedeExpr = newChildren(1).asInstanceOf[Expression[List[Integer]]]
    )
  }

  override def toString: String =
    s"value_precede_chain(${variablesExpr.toString}, ${valuesToPrecedeExpr.toString})"

  override def evalToString: String = {
    val variablesStr = variablesExpr.evalToString
    val valuesStr = valuesToPrecedeExpr.evalToString
    s"value_precede_chain($variablesStr, $valuesStr)"
  }


  override def eval(context: Map[String, Any]): Boolean = {
    val list = variablesExpr.eval(context)
    val valuesToPrecede = valuesToPrecedeExpr.eval(context)

    valuesToPrecede.sliding(2).forall {
      case List(valA, valB) =>

        val lastAIndexValue: Int = list.lastIndexWhere(_ == valA)
        val lastAIndex: Option[Int] = lastAIndexValue match {
          case -1 => None
          case i => Some(i)
        }

        val firstBIndexValue: Int = list.indexOf(valB)
        val firstBIndex: Option[Int] = firstBIndexValue match {
          case -1 => None
          case i => Some(i)
        }

        (lastAIndex, firstBIndex) match {
          case (None, _) => true
          case (_, None) => true
          case (Some(lastA), Some(firstB)) =>

            lastA < firstB
        }
      case _ => true
    }
  }

  override def distance(context: Map[String, Any]): Int = {
    if (eval(context)) return 0
    val list = variablesExpr.eval(context)
    val valuesToPrecede = valuesToPrecedeExpr.eval(context)

    valuesToPrecede.sliding(2).map {
      case List(valA, valB) =>

        val lastAIndexValue: Int = list.lastIndexWhere(_ == valA)
        val lastAIndex: Option[Int] = lastAIndexValue match {
          case -1 => None
          case i => Some(i)
        }

        val firstBIndexValue: Int = list.indexOf(valB)
        val firstBIndex: Option[Int] = firstBIndexValue match {
          case -1 => None
          case i => Some(i)
        }

        (lastAIndex, firstBIndex) match {
          case (Some(lastA), Some(firstB)) =>
            if (lastA >= firstB) lastA - firstB + 1 else 0

          case _ => 0
        }
      case _ => 0
    }.sum
  }

  override def signature: Signature = {
    Signature(
      inputs = List(ListIntType, ListIntType),
      output = BoolType
    )
  }
}


object ValuePrecedesChainExpression {

  object ValuePrecedesChainFactory extends Creatable with AutoNamed {
    override def templateSignature: Signature =
      Signature(
        inputs = List(ListIntType, ListIntType),
        output = BoolType
      )

    override def create(children: List[Expression[?]]): Expression[?] = {
      require(children.length == 2, "ValuePrecedesChainExpression.create requires two child.")

      val variablesExpr = children(0).asInstanceOf[Expression[List[Integer]]]
      val valuesToPrecedeExpr = children(1).asInstanceOf[Expression[List[Integer]]] // Drugie dziecko

      ValuePrecedesChainExpression(variablesExpr, valuesToPrecedeExpr)
    }

    override def ownerClass: Class[_] = ValuePrecedesChainExpression.getClass
  }
}


case class RedundantConstraint[T : ClassTag](
                                              innerConstraint: Expression[T]
                                            ) extends Expression[T]
  with ComposableExpression {

  override def children: List[Expression[?]] = List(innerConstraint)

  override def withNewChildren(newChildren: List[Expression[?]]): Expression[?] = {
    require(newChildren.length == 1, "RedundantConstraint requires exactly one child.")
    this.copy(innerConstraint = newChildren.head.asInstanceOf[Expression[T]])
  }

  override def toString: String =
    s"redundant_constraint(${innerConstraint.toString})"

  override def evalToString: String =
    s"redundant_constraint(${innerConstraint.evalToString})"

  override def eval(context: Map[String, Any]): T = {
    innerConstraint.eval(context)
  }


  override def distance(context: Map[String, Any]): Int = {
    innerConstraint.distance(context)
  }

  override def signature: Signature = {
    Signature(
      inputs = List(UnknownType),
      output = BoolType
    )
  }
}

object RedundantConstraint {
  object RedundantConstraintFactory extends Creatable {
    override def templateSignature: Signature =
      Signature(
        inputs = List(UnknownType),
        output = BoolType
      )

    override def create(children: List[Expression[?]]): Expression[?] = {
      require(children.length == 1, "RedundantConstraintExpression.create requires one child.")

      val innerConstraintExpr = children.head.asInstanceOf[Expression[Any]]

      RedundantConstraint(innerConstraintExpr)
    }
  }
}


case class StrEqExpression(
                            s1: Expression[String],
                            s2: Expression[String]
                          ) extends Expression[Boolean]
  with ComposableExpression {

  override def children: List[Expression[?]] = List(s1, s2)

  override def withNewChildren(newChildren: List[Expression[?]]): Expression[?] = {
    require(newChildren.length == 2, "StrEqExpression requires two children.")
    this.copy(
      s1 = newChildren(0).asInstanceOf[Expression[String]],
      s2 = newChildren(1).asInstanceOf[Expression[String]]
    )
  }

  override def toString: String =
    s"str_eq(${s1.toString}, ${s2.toString})"

  override def evalToString: String =
    s"str_eq(${s1.evalToString}, ${s2.evalToString})"


  override def eval(context: Map[String, Any]): Boolean = {
    val val1 = s1.eval(context)
    val val2 = s2.eval(context)

    val1.equals(val2)
  }


  override def distance(context: Map[String, Any]): Int = {
    if (eval(context)) 0 else 1
  }

  override def signature: Signature = {
    Signature(
      inputs = List(StringType, StringType),
      output = BoolType
    )
  }
}

object StrEqExpression {
  object StrEqFactory extends Creatable with AutoNamed {
    override def templateSignature: Signature =
      Signature(
        inputs = List(StringType, StringType),
        output = BoolType
      )

    override def create(children: List[Expression[?]]): Expression[?] = {
      require(children.length == 2, "StrEqExpression.create requires two children.")

      val s1Expr = children(0).asInstanceOf[Expression[String]]
      val s2Expr = children(1).asInstanceOf[Expression[String]]

      StrEqExpression(s1Expr, s2Expr)
    }

    override def ownerClass: Class[_] = StrEqExpression.getClass
  }
}

---

File: ./dataprovider/PersistenceManager.scala
package com.beepboop.app.dataprovider

import com.beepboop.app.astar.ModelNodeTMP
import com.beepboop.app.components.Expression
import com.beepboop.app.cpicker.ConstraintData
import com.beepboop.app.logger.LogTrait

import java.io.*
import scala.annotation.targetName
import scala.util.{Failure, Success, Try}

case class AStarSnapshot(
                          openSetItems: List[ModelNodeTMP],
                          visitedItems: Set[ModelNodeTMP]
                        ) extends Serializable

object PersistenceManager extends LogTrait {

  @targetName("ConstraintData")
  def saveConstraintsToCSV(cd: Iterable[ConstraintData], filename: String): Unit = {
    val file = new File(filename)
    Option(file.getParentFile).foreach(_.mkdirs())
    val bw = new BufferedWriter(new FileWriter(file))
    try {
      bw.write("Constraint_String|Score_f|Sol_count\n")

      cd.foreach { c =>
        val cleanStr = c.constraint.toString.replaceAll("[\r\n]+", " ")
        bw.write(s"$cleanStr|${c.heuristics}|${c.solCount}\n")
      }
      info(s"Saved ${cd.size} solutions to CSV: $filename")
    } catch {
      case e: Exception => error(s"Error writing CSV: ${e.getMessage}")
    } finally {
      bw.close()
    }

  }

  @targetName("ModelNodeTMP")
  def saveConstraintsToCSV(nodes: Iterable[ModelNodeTMP], filename: String): Unit = {
    val file = new File(filename)
    Option(file.getParentFile).foreach(_.mkdirs())
    val bw = new BufferedWriter(new FileWriter(file))
    try {
      bw.write("Constraint_String|Depth_g|Heuristic_h|Score_f\n")

      nodes.foreach { node =>
        val cleanStr = node.constraint.toString.replaceAll("[\r\n]+", " ")
        bw.write(s"$cleanStr|${node.g}|${node.h}|${node.f}\n")
      }
      info(s"Saved ${nodes.size} solutions to CSV: $filename")
    } catch {
      case e: Exception => error(s"Error writing CSV: ${e.getMessage}")
    } finally {
      bw.close()
    }
  }

  def saveAStarState(snapshot: AStarSnapshot, filename: String): Unit = {
    val file = new File(filename)
    Option(file.getParentFile).foreach(_.mkdirs())
    useObjectStream(filename) { out =>
      out.writeObject(snapshot)
    }
  }

  def loadAStarState(filename: String): Try[AStarSnapshot] = {
    Try {
      val fileIn = new FileInputStream(filename)
      val in = new ObjectInputStream(fileIn)
      try {
        in.readObject().asInstanceOf[AStarSnapshot]
      } finally {
        in.close()
        fileIn.close()
      }
    }
  }

  def saveCheckpoint(snapshot: AStarSnapshot, checkpointPath: String, csvPath: String): Unit = {
    saveAStarState(snapshot, checkpointPath)
    if (snapshot.visitedItems.nonEmpty) {
      saveConstraintsToCSV(snapshot.visitedItems, csvPath)
    }
  }

  def performEmergencyBackup(snapshot: AStarSnapshot, checkpointPath: String, csvPath: String): Unit = {
    try {
      scala.Console.err.println("\n!!! CAUGHT EXIT SIGNAL (Ctrl+C) !!!")
      scala.Console.err.println("Attempting emergency backup...")
      saveCheckpoint(snapshot, checkpointPath, csvPath) // Reuywamy saveCheckpoint!
      scala.Console.err.println("Emergency backup completed successfully.")
    } catch {
      case e: Exception => error(s"Emergency backup failed: ${e.getMessage}")
    }
  }

  private def useObjectStream(filename: String)(op: ObjectOutput => Unit): Unit = {
    try {
      val fileOut = new FileOutputStream(filename)
      val out = new ObjectOutputStream(fileOut)
      op(out)
      out.close()
      fileOut.close()
      info(s"Successfully saved binary state to $filename")
    } catch {
      case e: Exception => scala.Console.err.println(s"Emergency backup failed: ${e.getMessage}")
    }
  }
}

---

File: ./dataprovider/MinizincDznVisitor.scala
package com.beepboop.app

import com.beepboop.parser.NewMinizincParserBaseVisitor
import com.beepboop.parser.NewMinizincParser
import com.beepboop.app.dataprovider.DataItem
import scala.jdk.CollectionConverters._

class MinizincDznVisitor(dataItems: List[DataItem]) extends NewMinizincParserBaseVisitor[Any] {

  private val itemMap = dataItems.map(i => i.name -> i).toMap


  override def visitAssign_item(ctx: NewMinizincParser.Assign_itemContext): Any = {
    val id = ctx.ident().getText
    val valueExpr = ctx.expr()

    itemMap.get(id) match {
      case Some(item) =>
        val parsedValue = visit(valueExpr)
        item.value = parsedValue
      case None =>
    }
    null
  }


  override def visitExpr(ctx: NewMinizincParser.ExprContext): Any = {
    val left = visit(ctx.expr_atom())

    if (ctx.expr_binop_tail() != null && ctx.expr_binop_tail().bin_op() != null) {
      val binOp = ctx.expr_binop_tail().bin_op()
      if (binOp.builtin_bin_op() != null && binOp.builtin_bin_op().DOTDOT() != null) {
        val right = visit(ctx.expr_binop_tail().expr())
        return (left, right) match {
          case (l: Int, r: Int) => (l to r).toSet
          case _ => left
        }
      }
    }
    left
  }


  override def visitExpr_atom(ctx: NewMinizincParser.Expr_atomContext): Any = {
    if (ctx.expr_atom_head() != null) {
      return visit(ctx.expr_atom_head())
    }
    super.visitExpr_atom(ctx)
  }

  override def visitExpr_atom_head(ctx: NewMinizincParser.Expr_atom_headContext): Any = {
    if (ctx.int_literal() != null) return visit(ctx.int_literal())
    if (ctx.float_literal() != null) return visit(ctx.float_literal())
    if (ctx.bool_literal() != null) return visit(ctx.bool_literal())
    if (ctx.string_literal() != null) return visit(ctx.string_literal())
    if (ctx.array_literal() != null) return visit(ctx.array_literal())
    if (ctx.array_literal_2d() != null) return visit(ctx.array_literal_2d())
    if (ctx.set_literal() != null) return visit(ctx.set_literal())

    if (ctx.LPAREN() != null && ctx.expr() != null) return visit(ctx.expr())

    super.visitExpr_atom_head(ctx)
  }


  override def visitInt_literal(ctx: NewMinizincParser.Int_literalContext): Any =
    ctx.getText.toInt

  override def visitFloat_literal(ctx: NewMinizincParser.Float_literalContext): Any =
    ctx.getText.toDouble

  override def visitBool_literal(ctx: NewMinizincParser.Bool_literalContext): Any =
    ctx.getText.toBoolean

  override def visitString_literal(ctx: NewMinizincParser.String_literalContext): Any = {
    val txt = ctx.getText
    if (txt.length >= 2) txt.substring(1, txt.length - 1) else txt
  }


  override def visitArray_literal(ctx: NewMinizincParser.Array_literalContext): Any = {
    if (ctx.expr() == null) return List.empty
    ctx.expr().asScala.map(visit).toList
  }

  override def visitArray_literal_2d(ctx: NewMinizincParser.Array_literal_2dContext): Any = {
    if (ctx.array_row() == null) return List.empty
    ctx.array_row().asScala.map { rowCtx =>
      rowCtx.expr().asScala.map(visit).toList
    }.toList
  }


  override def visitSet_literal(ctx: NewMinizincParser.Set_literalContext): Any = {
    if (ctx.expr() == null) return Set.empty
    ctx.expr().asScala.map(visit).toSet
  }
}

---

File: ./dataprovider/SolutionParser.scala
package com.beepboop.app.dataprovider

import com.beepboop.app.dataprovider.{DataItem, DataType}
import com.beepboop.app.logger.LogTrait

import scala.io.Source
import scala.util.{Failure, Success, Try}

object SolutionParser extends LogTrait {

  def parse(filePath: String, separator: Char = ';', vars: List[DataItem]): List[Map[String, Any]] = {
    var source: Source = null
    try {
      source = Source.fromFile(filePath)
      val lines = source.getLines().filter(_.trim.nonEmpty).toList

      val schema: Map[String, DataType] = vars
        .filter(_.name != null)
        .map(v => v.name -> v.detailedDataType)
        .toMap

      lines match {
        case headerLine :: dataLines if dataLines.nonEmpty =>
          val headers = headerLine.split(separator).map(_.trim)

          dataLines.flatMap { line =>
            val values = line.split(separator).map(_.trim)

            if (headers.length == values.length) {
              val typedMap = headers.zip(values).map { case (header, valueStr) =>
                val dataTypeOption = schema.get(header).flatMap(Option(_))

                val parsedValue = dataTypeOption match {
                  case Some(dataType) => parseValue(valueStr, dataType)
                  case None           => valueStr
                }
                header -> parsedValue
              }.toMap
              Some(typedMap)
            } else {
              warn(s"Skipping row due to mismatched column count. Expected ${headers.length}, got ${values.length}: $line")
              None
            }
          }
        case _ =>
          warn("Solutions file is empty or contains only a header.")
          List.empty
      }
    } catch {
      case e: Exception =>
        error(s"reading solutions file [$filePath]: ${e.getMessage}")
        e.printStackTrace()
        List.empty
    } finally {
      if (source != null) source.close()
    }
  }

  private def parseValue(valueStr: String, dataType: DataType): Any = {
    if (dataType == null) return valueStr

    try {
      if (dataType.isArray) {
        parseArray(valueStr, dataType.dataType)
      } else {
        parseScalar(valueStr, dataType.dataType)
      }
    } catch {
      case e: Exception =>
        warn(s"Failed to parse '$valueStr' as ${dataType.dataType}: ${e.getMessage}")
        valueStr
    }
  }

  private def parseArray(arrayStr: String, typeName: String): List[Any] = {
    val cleanStr = arrayStr.trim.stripPrefix("[").stripSuffix("]")
    if (cleanStr.isEmpty) {
      List.empty
    } else {
      cleanStr.split(',')
        .map(_.trim)
        .map(elem => parseScalar(elem, typeName))
        .toList
    }
  }

  private def parseScalar(value: String, typeName: String): Any = {
    val lowerType = Option(typeName).getOrElse("string").toLowerCase

    if (lowerType.contains("bool")) {
      value.toLowerCase match {
        case "true" | "1" | "yes" => true
        case "false" | "0" | "no" => false
        case _ => value.toBooleanOption.getOrElse(value == "1")
      }
    }
    else if (lowerType.contains("float") || lowerType.contains("decimal")) {
      value.toDouble
    }
    else if (lowerType.contains("int") || lowerType.matches(".*\\d+\\.\\.\\d+.*") || lowerType.contains("var")) {
      value.toInt
    }
    else {
      value
    }
  }
}

---

File: ./dataprovider/DataImporter.scala
package com.beepboop.app.dataprovider


import scala.io.Source
import scala.util.{Failure, Success, Try}
import scala.language.postfixOps
import spray.json.*
import DefaultJsonProtocol.*
import com.beepboop.app.MinizincDznVisitor
import com.beepboop.app.logger.LogTrait
import com.beepboop.parser.NewMinizincParserBaseListener
import org.antlr.v4.runtime.{CharStreams, CommonTokenStream}
import com.beepboop.parser.{NewMinizincLexer, NewMinizincParser}

import scala.collection.JavaConverters.asScalaBufferConverter
import scala.collection.JavaConverters.collectionAsScalaIterableConverter
import scala.collection.JavaConverters.iterableAsScalaIterableConverter


object DataImporter extends DefaultJsonProtocol, LogTrait {


  def prepareSets(data: String, dataItems: List[DataItem]): Unit = {
    dataItems.filter(_.detailedDataType.isSet).foreach { item =>
      val expr = item.expr

      if (expr != "") {
        try {
          val parts = parseRange(expr)

          val minVal = resolveBound(parts(0), dataItems)
          val maxVal = resolveBound(parts(1), dataItems)

          val setValues = (minVal to maxVal).toList
          item.value = setValues

          info(s"Set ${item.name} resolved: $minVal..$maxVal (size: ${setValues.size})")
        } catch {
          case e: Exception =>
            warn(s"Failed to resolve set '${item.name}' with expr '$expr': ${e.getMessage}")
        }
      }
    }
  }

  def resolveBound(boundStr: String, dataItems: List[DataItem]): Int = {
    val raw = boundStr.trim

    if (raw.matches("-?\\d+")) {
      return raw.toInt
    }

    val sumPattern = "sum\\((.*)\\)".r
    raw match {
      case sumPattern(varName) =>
        val listValue = lookupDependency(varName, dataItems)
        listValue match {
          case l: List[_] => l.map(_.toString.toInt).sum
          case _ => throw new IllegalArgumentException(s"Item '$varName' is not a list, cannot calculate sum.")
        }

      case varName =>
        val value = lookupDependency(varName, dataItems)
        value.toString.toInt
    }
  }

  def lookupDependency(name: String, dataItems: List[DataItem]): Any = {
    dataItems.find(d => d.name == name && !d.isVar) match {
      case Some(foundItem) =>
        if (foundItem.value == null || foundItem.value == None) {
          throw new IllegalArgumentException(s"Dependency '$name' found but has no value yet.")
        }
        foundItem.value
      case None =>
        throw new IllegalArgumentException(s"Dependency '$name' not found in dataItems.")
    }
  }
  def resolveValue(value: Any): Any = {
    value match {
      case key: String => DataProvider.getValue(key)
      case other => other
    }
  }
  def parseRange(expr: String): Array[String] = {
    val parts = expr.split("\\.\\.")
    require(parts.length == 2, s"Invalid range format for expr: $expr")
    parts
  }

  def parseJson(data: String, dataItems: List[DataItem], parseVars: Boolean = false): Unit = {
    val jsonObject = data.parseJson.asJsObject
    if (parseVars) {
      dataItems.filter(_.isVar).foreach { item =>
        (jsonObject.fields.get(item.name), item.detailedDataType) match {
          case (Some(jsValue), details) if details != null =>
            try {
              val convertedValue: Any = (details.isArray, details.dataType) match {
                case (true, "int") =>
                  Try(jsValue.convertTo[List[List[Int]]]).getOrElse(jsValue.convertTo[List[Int]])
                case (true, "float") =>
                  Try(jsValue.convertTo[List[List[Double]]]).getOrElse(jsValue.convertTo[List[Double]])
                case (true, "bool") =>
                  Try(jsValue.convertTo[List[List[Boolean]]]).getOrElse(jsValue.convertTo[List[Boolean]])
                case (true, "string") => jsValue.convertTo[List[String]]
                case (false, "int") => jsValue.convertTo[Int]
                case (false, "float") => jsValue.convertTo[Double]
                case (false, "bool") => jsValue.convertTo[Boolean]
                case (false, "string") => jsValue.convertTo[String]
                case (_, unknownType) =>
                  warn(s"Unsupported data type: $unknownType for item ${item.name}")
                  None
              }
              item.value = convertedValue
              info(s"Successfully parsed data for ${item.name}: ${item.value}")
            } catch {
              case e: DeserializationException =>
                error(s"Error converting data for ${item.name}: ${e.getMessage}")
            }

          case (None, _) =>
            warn(s"No data found for key: ${item.name}")

          case (Some(_), null) =>
            warn(s"No detailed data type found for item: ${item.name}")
        }
      }


    } else {
      dataItems.filter(!_.isVar).foreach { item =>
        (jsonObject.fields.get(item.name), item.detailedDataType) match {
          case (Some(jsValue), details) if details != null =>
            try {
              val convertedValue: Any = (details.isArray, details.dataType) match {
                case (true, "int") => jsValue.convertTo[List[Int]]
                case (true, "float") => jsValue.convertTo[List[Double]]
                case (true, "bool") => jsValue.convertTo[List[Boolean]]
                case (true, "string") => jsValue.convertTo[List[String]]
                case (false, "int") => jsValue.convertTo[Int]
                case (false, "float") => jsValue.convertTo[Double]
                case (false, "bool") => jsValue.convertTo[Boolean]
                case (false, "string") => jsValue.convertTo[String]
                case (_, unknownType) =>
                  warn(s"Unsupported data type: $unknownType for item ${item.name}") // todo: add deduction based on previously defined var
                  None
              }
              item.value = convertedValue
              info(s"Successfully parsed data for ${item.name}: ${item.value}")
            } catch {
              case e: DeserializationException =>
                warn(s"Error converting data for ${item.name}: ${e.getMessage}")
            }

          case (None, _) =>
            warn(s"No data found for key: ${item.name}")

          case (Some(_), null) =>
            warn(s"No detailed data type found for item: ${item.name}")
        }
      }

    }
  }

  def parseDzn(data: String, dataItems: List[DataItem]): Unit = {
    try {
      val charStream = CharStreams.fromString(data)
      val lexer = new NewMinizincLexer(charStream)
      val tokens = new CommonTokenStream(lexer)
      val parser = new NewMinizincParser(tokens)

      val tree = parser.model()

      val visitor = new MinizincDznVisitor(dataItems)

      tree.item().asScala.foreach { itemCtx =>
        if (itemCtx.assign_item() != null) {
          visitor.visitAssign_item(itemCtx.assign_item())
        }
      }

      dataItems.filter(_.value != None).foreach { item =>
        info(s"Parsed DZN value for ${item.name}: ${item.value}")
      }

    } catch {
      case e: Exception =>
        error(s"Error parsing DZN file: ${e.getMessage}")
    }
  }

  def tryAutoDetectType(values: Array[String], isArray: Boolean): Any = {
    debug(values.head)
    if (isArray) {
      val intList = Try(values.map(_.toInt).toList).toOption
      if (intList.isDefined) return intList.get

      val doubleList = Try(values.map(_.toDouble).toList).toOption
      if (doubleList.isDefined) return doubleList.get

      val boolList = Try(values.map(_.toLowerCase match {
        case "true" | "1" | "yes"  => true
        case "false" | "0" | "no"  => false
        case _ => throw new IllegalArgumentException("Not a boolean")
      }).toList).toOption
      debug(boolList.toString)
      if (boolList.isDefined) return boolList.get

      return values.toList
    } else {
      val value = values.head

      Try(value.toInt).toOption.foreach(v => return v)
      Try(value.toDouble).toOption.foreach(v => return v)
      Try(value.toLowerCase match {
        case "true" | "1" | "yes" => true
        case "false" | "0" | "no" => false
        case _ => throw new IllegalArgumentException("Not a boolean")
      }).toOption.foreach(v => return v)

      value
    }
  }

  def parseCsv(data: String, dataItems: List[DataItem], parseVars: Boolean = false): Unit = {
    val lines = data.split("\n").map(_.trim).filter(_.nonEmpty)
    if (lines.isEmpty) {
      error("CSV file is empty")
      return
    }

    val headers = lines.head.split(";").map(_.trim)
    val dataRows = lines.tail

    val targetItems = if (parseVars) dataItems.filter(_.isVar) else dataItems.filter(!_.isVar)

    targetItems.foreach { item =>
      headers.zipWithIndex.find(_._1 == item.name) match {
        case Some((_, colIdx)) =>
          try {
            val columnValues = dataRows.map(_.split(";").apply(colIdx).trim)

            val convertedValues: List[Any] = if (item.detailedDataType != null) {
              item.detailedDataType.dataType match {
                case "int" =>
                  columnValues.map(_.toInt).toList
                case "float" =>
                  columnValues.map(_.toDouble).toList
                case "bool" =>
                  columnValues.map {
                    case "true" | "1" | "yes"  => true
                    case "false" | "0" | "no"  => false
                    case other => throw new IllegalArgumentException(s"Cannot convert '$other' to boolean")
                  }.toList
                case "string" =>
                  columnValues.toList
                case otherType =>
                  warn(s"Unknown data type $otherType for item ${item.name}, attempting auto-detection")
                  tryAutoDetectType(columnValues, isArray = true).asInstanceOf[List[Any]]
              }
            } else {
              warn(s"Missing detailedDataType for item ${item.name} in CSV, attempting auto-detection")
              tryAutoDetectType(columnValues, isArray = true).asInstanceOf[List[Any]]
            }

            item.value = convertedValues

            info(s"Parsed CSV data for ${item.name}: ${item.value}")

          } catch {
            case e: Exception =>
              warn(s"Error parsing CSV data for ${item.name}: ${e.getMessage}")
          }

        case None =>
          warn(s"No column found for key: ${item.name}")
      }
    }
  }

  def importDataFile(filename: String, dataItems: List[DataItem], importVar: Boolean = false): Unit = {
    val dataContent: String = Source.fromFile(filename).mkString
    debug(filename)
    filename.trim.split("\\.").last match {
      case "json" => parseJson(dataContent, dataItems, importVar)
      case "dzn" => parseDzn(dataContent, dataItems)
      case "csv" => parseCsv(dataContent, dataItems, importVar)
      case ext => warn(s"Unsupported file extension: $ext")
    }
    prepareSets(dataContent, dataItems)
  }
}

---

File: ./dataprovider/ModelItems.scala
package com.beepboop.app.dataprovider

sealed trait ModelItem {
  def name: String
}

case class DataType(
                   dataType: String,
                   isArray: Boolean,
                   isIdentifier: Boolean, // todo: isSet?
                   isSet: Boolean = false,
                   )

case class DataItem(
                     override val name: String,
                     dataType: String,
                     isVar: Boolean,
                     var value: Any = None,
                     detailedDataType: DataType = null,
                     expr: String,
                   ) extends ModelItem


---

File: ./dataprovider/DataProvider.scala
package com.beepboop.app.dataprovider

/* third party modules */
import org.antlr.v4.runtime.tree.ParseTreeWalker
import org.antlr.v4.runtime.{CharStream, CharStreams, CommonTokenStream, TokenStream}

import javax.lang.model.util.Elements.Origin
import scala.io.Source

/* own modules */
import com.beepboop.app.components.*
import com.beepboop.app.MinizincModelListener
import com.beepboop.app.ParserUtil
import com.beepboop.app.{GrammarConverter, ParsedGrammar}
import com.beepboop.app.components.Variable
import com.beepboop.app.logger.LogTrait
import com.beepboop.parser.{NewMinizincLexer, NewMinizincParser, NewMinizincParserBaseListener}


sealed trait DataItemRegistry {
  def getValue(name: String): Any
}

object DataProvider extends LogTrait {
  var solutionCount: Int = 0
  private var solutionNumber: Int = 0
  private var originalModelPath: Option[String] = None
  private var dataPath: Option[String] = None
  private var solutionsPath: Option[String] = None

  // These will hold the raw data after initialization
  var parameters: List[DataItem] = Nil
  var variables: List[DataItem] = Nil
  var tmpVars: List[DataItem] = List()
  private var variableCreatables: Option[List[Creatable]] = None
  var solutionContexts: Vector[Map[String, Any]] = Vector();


  def getSolutionNumber: Int = solutionNumber

  def createSolutionContext(solutionNumber: Int): Map[String, Any] =  {
    val solutionMap: Map[String, Any] = VarRegistry.dataVars(solutionNumber)
    val parameterMap: Map[String, Any] = ParameterRegistry.dataPars.map(di => di.name -> di.value).toMap
    val tMap = solutionMap ++ parameterMap
    tMap
  }

  def getSolutionContext(solutionNumber: Int): Map[String, Any] = {
    solutionContexts.apply(solutionNumber)
  }

  def initalize(originalModelPath: String, dataPath: String, solutionsPath: String): Unit = {
    this.originalModelPath = Some(originalModelPath)
    this.dataPath = Some(dataPath)
    this.solutionsPath = Some(solutionsPath)

    val (params, vars) = ModelParser.getDataItems(this.originalModelPath.get)

    this.parameters = params
    this.variables = vars



    VarRegistry.load()
    ParameterRegistry.load()

    variables.foreach(v => VarRegistry.dataVars.contains(v.name) )

    val groupedVars: Map[ExpressionType, List[DataItem]] = (variables ++ (ParameterRegistry.dataPars.filter(_.value != None))).groupBy { item =>
      item.dataType match {
        case "int" => IntType
        case t if t.contains("array") && t.contains("int") => ListIntType
        case "set of int" => ListIntType // todo: prepare correct SetType
        case "bool" => BoolType
        case _ => UnknownType
      }
    }





    groupedVars.foreach { case (exprType, dataItems) =>
      debug(s"  -> Type: $exprType, Items: ${dataItems.map(_.name).mkString(", ")}")
    }

    this.variableCreatables = Some(
      groupedVars.map {
        case (exprType, dataItems) =>
        debug(s"Creating variableCreatables exprType $exprType, ${dataItems.map(_.name).mkString(", ")}")
        new RandomVariableFactory(exprType, dataItems.map(_.name))
      }.toList
    )

    this.solutionContexts = (0 until solutionCount).map(createSolutionContext).toVector
  }

  def getValue(name: String): Any = {
      val paramValue = ParameterRegistry.getValue(name)
      if (paramValue != None) {
        return paramValue
      }
      val varValue = VarRegistry.getValue(name)
      if (varValue != None) {
        if (this.variables.filter(_.name == name).head.detailedDataType.isArray) {
          val value = varValue.get.asInstanceOf[List[Any]]
          return value
        }
        else {
          return varValue.get
        }
      }
      throw new NoSuchElementException(s"No value found for '$name' in either parameters or variables for solution $solutionNumber.")
  }


  object VarRegistry extends LogTrait {
    val dataVars = {
      info(s"Parsing known solutions from: $solutionsPath...")
//      DataImporter.importDataFile(solutionsPath.getOrElse(throw new IllegalStateException("DataProvider not initialized.")), variables, true)
//      info(s"From ${variables.size} dataItems")
//      info(s"  ->${variables.filter(_.isVar).size} vars")
//      info(s"  ->${variables.count(_.value != None)} have assigned value")
//
//      variables.filter(_.value != None).foreach { d =>
//        info(s"  | Name: ${d.name}, Value count: ${d.value.asInstanceOf[List[Any]].size}, Type: ${d.dataType}, Runtime: ${d.value.asInstanceOf[List[Any]].head.getClass.getSimpleName} First value: ${d.value.asInstanceOf[List[Any]].head}")
//      }
//      variables.filter(_.value != None)


      val knownSolutions = SolutionParser.parse(solutionsPath.get, separator = ';', DataProvider.this.variables)
      if (knownSolutions.nonEmpty) {
        info("Updating variable data types based on the first found solution...")
        val firstSolutionMap = knownSolutions.head

        DataProvider.this.variables = DataProvider.this.variables.map { dataItem =>
          debug(s"DataItem is $dataItem")
          if (dataItem.detailedDataType != null) {
            dataItem
          } else {
            firstSolutionMap.get(dataItem.name) match {
              case Some(valueFromSolution) =>
                val (newDataTypeString, newDetailedType) = ModelParser.deriveDataType(valueFromSolution)
                debug(s"New typeString is: " + newDataTypeString)
                debug(s"New detailedType is: " + newDetailedType)
                dataItem.copy(
                  dataType = newDataTypeString,
                  detailedDataType = newDetailedType
                )
              case None =>
                dataItem
            }
          }
        }
        debug("Variable types have been updated.")
        DataProvider.this.variables.filter(_.isVar).foreach(v => debug(s"  -> ${v.name}: ${v.dataType}"))
      }

      if (knownSolutions.isEmpty) {
        throw new IllegalStateException("No solutions found in output file. Aborting.")
      }
      info(s"Found ${knownSolutions.size} solutions to test against.")
      DataProvider.this.solutionCount = knownSolutions.size

      info(s"Found ${knownSolutions.size} solutions to test against.")
      if (knownSolutions.isEmpty) {
        throw new IllegalStateException("No solutions found in output file. Aborting.")
      }
      knownSolutions.toVector

    }
    def load(): Unit = { return }
    def get(requiredType: ExpressionType): List[DataItem] = {
      if (variables.isEmpty) throw new IllegalStateException("DataProvider not initialized.")

      variables.filter { item =>
        val itemType = if (item.dataType == "int") IntType
        else if (item.dataType.contains("array") && item.dataType.contains("int")) ListIntType
        else if (item.dataType == "bool") BoolType
        else UnknownType
        itemType == requiredType
      }
    }

    def getValue(name: String): Option[Any] = {
      dataVars.apply(solutionNumber).get(name)
    }
  }

  object ParameterRegistry extends LogTrait {
    def load(): Unit = { return }
    val dataPars = {
      DataImporter.importDataFile(dataPath.getOrElse(throw new IllegalStateException("DataProvider not initialized.")), parameters)
      info(s"From ${parameters.size} dataItems")
      info(s"  ->${parameters.filter(!_.isVar).size} pars")
      info(s"  ->${parameters.count(_.value != None)} have assigned value")

      parameters.filter(_.value != None).foreach { d =>
        info(s"  | Name: ${d.name}, Value: ${d.value}")
      }
      parameters.filter(_.value != None)
    }

    def getAll(): List[DataItem] = {
      if (parameters.isEmpty) throw new IllegalStateException("DataProvider not initialized.")
      parameters
    }

    def getValue(name: String): Any = {
      if (dataPars.filter(_.name == name).isEmpty) return None
      dataPars.filter(_.name == name).head.value
    }
  }


  def getVariableCreatables: List[Creatable] = {
    variableCreatables.getOrElse(throw new IllegalStateException("DataProvider not initialized."))
  }
}


object ModelParser extends LogTrait {
  /* todo: figure out the correct place for this code
  val internalGrammar: ParsedGrammar = {
    val tGrammar = GrammarConverter.parseConstraintGrammar()
    debug(tGrammar.toString)
    tGrammar
  }
   */
  def getDataItems(originalModelPath: String): (List[DataItem], List[DataItem]) = {
    info(s"Reading and parsing model file $originalModelPath")
    val modelCode: String = Source.fromFile(originalModelPath).mkString
    val (_, mzparseTree) = ParserUtil.parseCode(
      code = modelCode,
      lexerFactory = (cs: CharStream) => new NewMinizincLexer(cs),
      parserFactory = (ts: TokenStream) => new NewMinizincParser(ts),
      startRuleInvoker = (p: NewMinizincParser) => p.model()
    )

    debug("Extracting all variable and parameter declarations")
    val input: CharStream = CharStreams.fromString(modelCode)
    val lexer = new NewMinizincLexer(input)
    val tokens = new CommonTokenStream(lexer)
    val modelListener = new MinizincModelListener(tokens)

    new ParseTreeWalker().walk(modelListener, mzparseTree)
    val allDeclaredItems = modelListener.getDataItems
    debug(s"Found ${allDeclaredItems}")

    val modelDataItems = allDeclaredItems.filter(!_.isVar)
    val availableVariables = allDeclaredItems.filter(_.isVar).map(_.name)
    val availableVars = allDeclaredItems.filter(_.isVar)

    debug(s"Found ${modelDataItems.size} data items (parameters):")
    modelDataItems.foreach(item => debug(s"  -> Name: ${item.name}, Type: '${item.dataType}'"))

    debug(s"Found ${availableVariables.size} constraint variables:")
    availableVariables.foreach(item => debug(s"  -> Name: ${item}"))
    (modelDataItems,availableVars)
  }


  def deriveDataType(value: Any): (String, DataType) = {
    value match {
      case _: Int =>
        ("int", DataType(dataType = "int", isArray = false, isIdentifier = false))
      case _: Boolean =>
        ("bool", DataType(dataType = "bool", isArray = false, isIdentifier = false))
      case _: Double | _: Float =>
        ("float", DataType(dataType = "float", isArray = false, isIdentifier = false))
      case _: String =>
        ("string", DataType(dataType = "string", isArray = false, isIdentifier = false))

      case ls: List[_] if ls.nonEmpty =>
        ls.head match {
          case _: Int => ("array[int]", DataType(dataType = "int", isArray = true, isIdentifier = false))
          case _: Boolean => ("array[bool]", DataType(dataType = "bool", isArray = true, isIdentifier = false))
          case _: Double | _: Float => ("array[float]", DataType(dataType = "float", isArray = true, isIdentifier = false))
          case _: String => ("array[string]", DataType(dataType = "string", isArray = true, isIdentifier = false))
          case _ => ("array[unknown]", DataType(dataType = "unknown", isArray = true, isIdentifier = false))
        }

      case _: List[_] =>
        ("array[unknown]", DataType(dataType = "unknown", isArray = true, isIdentifier = false))

      case _ =>
        val typeName = value.getClass.getSimpleName.toLowerCase
        (typeName, DataType(dataType = typeName, isArray = false, isIdentifier = false))
    }
  }


}

object VarNameGenerator {
  private var counter: Int = 0

  def generateUniqueName(prefix: String = "tmp_var"): String = synchronized {
    val newName = s"${prefix}_${counter}"
    counter += 1
    newName
  }
}


---

File: ./logger/LogConfigProvider.scala
package com.beepboop.app.logger


import org.yaml.snakeyaml.Yaml
import scala.jdk.CollectionConverters._
import java.io.FileInputStream


case class ClassLogConfig(level: String, enable: Boolean)



private def toScala(value: Any): Any = value match {
  case m: java.util.Map[_, _] =>
    m.asScala.view.mapValues(toScala).toMap
  case l: java.util.List[_] =>
    l.asScala.map(toScala).toList
  case other => other
}


// From map to ClassLogConfig
object ClassLogConfigMapper {
  def fromMap(data: Map[String, Object]): ClassLogConfig = {
    val level: String = data.getOrElse("level", "INFO").toString
    val enable: Boolean = data.getOrElse("enabled", false).toString.toBoolean
    ClassLogConfig(level, enable)
  }
}

object LogConfigProvider {
  private val configFile = "src/main/resources/logging.yml"

  // once
  private lazy val config: Map[String, Object] = {
    val yaml = new Yaml()
    val input = new FileInputStream(configFile)
    val data = yaml.load[java.util.Map[String, Object]](input)
    input.close()

    toScala(data).asInstanceOf[Map[String, Object]]
  }

  // getters
  def logLevel: String = config.getOrElse("level", "INFO").toString
  def logEnabled: Boolean = config.getOrElse("enabled", true).toString.toBoolean
  def logConfigDebugEnabled: Boolean = config.getOrElse("log_debug", false).toString.toBoolean
  def classLogConfig(className: String): ClassLogConfig = {
    // class name returned using getClass.getName have an extra $ at the end
    val raw = config.getOrElse(className.stripSuffix("$"), Map[String, Object]()).asInstanceOf[Map[String, Object]]
    ClassLogConfigMapper.fromMap( raw )
  }

}



---

File: ./logger/LogTrait.scala
package com.beepboop.app.logger

// third party
import org.slf4j.LoggerFactory
import com.typesafe.scalalogging.Logger
// own
import com.beepboop.app.logger.*


trait LogTrait {

  @transient
  protected lazy val logger: Logger = {
    Logger(LoggerFactory.getLogger(getClass.getName))
  }

  private lazy val globalLogEnable: Boolean = LogConfigProvider.logEnabled
  private lazy val logConfigDebug: Boolean = LogConfigProvider.logConfigDebugEnabled
  private lazy val logConfig: ClassLogConfig = {
    val tLogConfig = LogConfigProvider.classLogConfig(getClass.getName)
    if(logConfigDebug) logger.debug(s"Config for: ${getClass.getName} |  level: ${tLogConfig.level} | gEnable: ${globalLogEnable} | enabled: ${tLogConfig.enable}")
    tLogConfig
  }


  private def shouldLog(level: String): Boolean = {
    if (!globalLogEnable) return false
    if (!logConfig.enable) return false

    val order = Seq("DEBUG", "INFO", "WARN", "ERROR")
    val configIdx = order.indexOf(logConfig.level.toUpperCase)
    val msgIdx = order.indexOf(level.toUpperCase)

    msgIdx >= configIdx
  }


  def debug(message: String): Unit = {
    if (shouldLog("DEBUG")) logger.debug(message)
  }
  def info(message: String): Unit = {
    if (shouldLog("INFO")) logger.info(message)
  }
  def warn(message: String): Unit = {
    if (shouldLog("WARN")) logger.warn(message)
  }
  def error(message: String): Unit = {
    if (shouldLog("ERROR")) logger.error(message)
  }
}



---

File: ./logger/Profiler.scala
package com.beepboop.app.logger

import scala.collection.mutable
import java.util.concurrent.ConcurrentHashMap
import scala.jdk.CollectionConverters._

object Profiler {

  private val timings = new ConcurrentHashMap[String, mutable.ListBuffer[Long]]().asScala
  private val values = new ConcurrentHashMap[String, mutable.ListBuffer[Long]]().asScala

  /**
   * profiles the execution time of a block
   * @param name name of the block
   * @param block executable block, scope
   * @tparam T return type of the block
   * @example  profile("test") { long_func() }
   */
  def profile[T](name: String)(block: => T): T = {
    val startTime = System.nanoTime()

    val result = try {
      block
    } finally {
      val endTime = System.nanoTime()
      val duration = endTime - startTime

      val durations = timings.getOrElseUpdate(name, mutable.ListBuffer.empty[Long])

      durations.synchronized {
        durations += duration
      }
    }

    result
  }

  /**
   * Sums given value to the variable with the name
   * @param name name of the variable
   * @param value value to add
   */
  def recordValue(name: String, value: Long): Unit = {
    val list = values.getOrElseUpdate(name, mutable.ListBuffer.empty[Long])
    list.synchronized {
      list += value
    }
  }


  def reset(): Unit = {
    timings.clear()
    values.clear()
  }

  def report(): Unit = {
    val headerFmt = "| %-50s | %8s | %14s | %14s | %14s | %14s |"
    val rowFmt    = "| %-50s | %8d | %14.2f | %14.2f | %14.2f | %14.2f |"
    val separator = "|%s|%s|%s|%s|%s|%s|"
      .format("-" * 52, "-" * 10, "-" * 16, "-" * 16, "-" * 16, "-" * 16)

    def printTable(
                    title: String,
                    data: mutable.Map[String, mutable.ListBuffer[Long]],
                    unitConverter: Double => Double,
                    unitName: String
                  ): Unit = {
      println(s"\n--- $title ---")
      println(headerFmt.format("Name", "Calls", s"Total ($unitName)", s"Avg ($unitName)", s"Min ($unitName)", s"Max ($unitName)"))
      println(separator)

      if (data.isEmpty) {
        println(s"| No $title recorded.".padTo(129, ' ') + "|")
        println(separator)
        return
      }

      val sortedData = data.toSeq.sortBy(_._1)

      for ((name, records) <- sortedData) {
        val (count, total, minVal, maxVal) = records.synchronized {
          if (records.isEmpty) (0, 0L, 0L, 0L)
          else (records.length, records.sum, records.min, records.max)
        }

        if (count > 0) {
          val avg = total.toDouble / count
          println(rowFmt.format(
            name,
            count,
            unitConverter(total.toDouble),
            unitConverter(avg),
            unitConverter(minVal.toDouble),
            unitConverter(maxVal.toDouble)
          ))
        }
      }
      println(separator)
    }

    printTable("Profiler Timings", timings, ns => ns / 1_000_000.0, "ms")

    printTable("Custom Metrics", values, v => v, "val")

    println()
  }
}

---

File: ./mutations/ExpressionGenerator.scala
package com.beepboop.app.mutations
/* own modules */
import com.beepboop.app.components.*
import com.beepboop.app.logger.LogTrait


case class GenerationContext(
                              variables: Map[ExpressionType, List[String]] = Map.empty
                            ) {
  def withVariable(name: String, varType: ExpressionType): GenerationContext = {
    val existingNames = variables.getOrElse(varType, List.empty)
    copy(variables = variables + (varType -> (name :: existingNames)))
  }
}

object ExpressionGenerator extends LogTrait {

  def generate(
                requiredType: ExpressionType,
                maxDepth: Int,
                ctx: GenerationContext = GenerationContext()
              ): Option[Expression[?]] = {

    val registry = ComponentRegistry

    val globalCreatables = if (maxDepth <= 0) {
      registry.findCreatablesReturning(requiredType).filter(_.templateSignature.inputs.isEmpty)
    } else {
      registry.findCreatablesReturning(requiredType)
    }

    val localNames = ctx.variables.getOrElse(requiredType, Nil)
    val localCreatables = if (localNames.nonEmpty) {
      List(new RandomVariableFactory(requiredType, localNames))
    } else {
      Nil
    }

    val possibleCreatables = globalCreatables ++ localCreatables
    debug(s"--- Selection Pool [Depth: $maxDepth, Type: $requiredType] ---")
    possibleCreatables.foreach { c =>
      val kind = c match {
        case _: RandomVariableFactory => "[LOCAL VAR]"
        case _: ContextAwareCreatable => "[SCOPED OP]"
        case x if x.templateSignature.inputs.isEmpty => "[CONSTANT ]"
        case _ => "[OPERATOR ]"
      }
      debug(s"$kind ${c.getClass.getName} -> Returns: ${c.templateSignature.output}")
    }
    debug(s"-------------------------------------------------------------")
    if (possibleCreatables.isEmpty) {

      return None
    }
    val chosenCreatable = selectWeighted(possibleCreatables)


    debug(s"Selected: ${chosenCreatable.getClass.getName}")



    chosenCreatable match {
      case scoped: ContextAwareCreatable =>
        scoped.generateExpression(ctx, (t, c) => generate(t, maxDepth - 1, c))

      case standard =>
        val inputs = standard.templateSignature.inputs
        val children = inputs.map(inputType => generate(inputType, maxDepth - 1, ctx)) // Pass same ctx

        if (children.forall(_.isDefined)) {
          Some(standard.create(children.flatten))
        } else {
          None
        }
    }
  }

  private def selectWeighted(candidates: List[Creatable]): Creatable = {
    val registry = ComponentRegistry

    val candidatesWithWeights = candidates.map { c =>
      val weight = c match {
        case _: RandomVariableFactory => 50.0
        case _ => registry.getWeight(c)
      }
      (c, weight)
    }

    val totalWeight = candidatesWithWeights.map(_._2).sum

    if (totalWeight <= 0) return candidates(scala.util.Random.nextInt(candidates.length))

    val randomValue = scala.util.Random.nextDouble() * totalWeight

    var cumulativeWeight = 0.0
    for ((creatable, weight) <- candidatesWithWeights) {
      cumulativeWeight += weight
      if (randomValue < cumulativeWeight) {
        return creatable
      }
    }

    candidates.last
  }

  private def sequence[T](opts: List[Option[T]]): Option[List[T]] =
    opts.foldRight[Option[List[T]]] (Some(Nil)) { (opt, acc) =>
      for (x <- opt; xs <- acc) yield x :: xs

    }
}


trait ContextAwareCreatable extends Creatable {
  def generateExpression(
                          ctx: GenerationContext,
                          recurse: (ExpressionType, GenerationContext) => Option[Expression[?]]
                        ): Option[Expression[?]]
}

---

File: ./mutations/Mutation.scala
package com.beepboop.app.mutations

/* own modules */
import com.beepboop.app.components
import com.beepboop.app.components.{ComponentRegistry, Constant, Expression, OperatorContainer, RandomVariableFactory, Variable}
import com.beepboop.app.dataprovider.DataProvider
import com.beepboop.app.logger.LogTrait

trait Mutation extends LogTrait {
  def name: String
  def apply(expression: Expression[?], ctx: GenerationContext): Option[Expression[?]]
}



object ReplaceOperator extends Mutation {
  override def name: String = "ReplaceOperator"

  override def apply(expression: Expression[?], ctx: GenerationContext): Option[Expression[?]] = {
    expression match {
      case container: OperatorContainer =>
        val compatibleOps = ComponentRegistry
          .findOperatorsWithSignature(container.operator.signature)
          .filter( cpo => 
            { debug(s"${cpo.toString} != ${container.operator.toString}")
            cpo.toString != container.operator.toString}) // todo: testing with strings
        debug(s"All available operators for signature ${container.operator.signature} are ${compatibleOps.map(_.toString)}")

        if (compatibleOps.nonEmpty) {
          val newOp = compatibleOps(scala.util.Random.nextInt(compatibleOps.length))
          Some(container.withNewOperator(newOp))
        } else {
          None
        }
      case _ => None
    }
  }
}

object TransformVariableToConstant extends Mutation {
  override def name: String = "TransformVariableToConstant"

  override def apply(expression: Expression[?], ctx: GenerationContext): Option[Expression[?]] = {
    expression match {
      case v: Variable[?] =>
        val requiredType = v.signature.output
        val constantFactory = ComponentRegistry.findCreatablesReturning(requiredType)
          .find(_.templateSignature.inputs.isEmpty)

        constantFactory.map(_.create(Nil))

      case _ => None
    }
  }
}

object TransformConstantToVariable extends Mutation {
  override def name: String = "TransformVariableToConstant"


  override def apply(expression: Expression[?], ctx: GenerationContext): Option[Expression[?]] = {
    expression match {
      case c: Constant[?] =>

        val requiredType = c.signature.output

        val possibleFactories = ComponentRegistry.findCreatablesReturning(requiredType)
          .filter(_.templateSignature.inputs.isEmpty)

        val variableFactory = possibleFactories.collectFirst {
          case factory: RandomVariableFactory => factory
        }
        variableFactory.map(_.create(Nil))
      case _ =>
        None
    }
  }
}


object ChangeVariable extends Mutation {
  override def name: String = "ChangeVariable"

  override def apply(expression: Expression[?], ctx: GenerationContext): Option[Expression[?]] = {
    expression match {
      case v: Variable[?] =>
        val requiredType = v.signature.output
        val currentName = v.name

        val variableFactory = ComponentRegistry.creatables.collectFirst {
          case factory: RandomVariableFactory if factory.varType == requiredType => factory
        }

        variableFactory.flatMap { factory =>
          val alternativeNames = factory.availableNames.filter(_ != currentName)

          if (alternativeNames.nonEmpty) {
            val newName = alternativeNames(scala.util.Random.nextInt(alternativeNames.length))

            Some(factory.createWithName(newName))
          } else {
            None
          }
        }
      case _ => None
    }
  }
}


class ReplaceSubtree(val maxDepth: Int) extends Mutation {
  override def name: String = "ReplaceSubtree"

  override def apply(expression: Expression[?], ctx: GenerationContext): Option[Expression[?]] = {
    val requiredType = expression.signature.output

    val generated = ExpressionGenerator.generate(requiredType, maxDepth = maxDepth, ctx)
    debug(s"generated expressions are: $generated")
    generated


  }
}

---

File: ./mutations/MutationEngine.scala
package com.beepboop.app.mutations

/* own modules */
import com.beepboop.app.components.*
import com.beepboop.app.logger.LogTrait

object AllMutations {
  val mutations: List[Mutation] = List(
    ReplaceOperator,
    TransformVariableToConstant,
    TransformConstantToVariable,
    ChangeVariable,
    ReplaceSubtree(1),
    ReplaceSubtree(2),
    ReplaceSubtree(3),
    ReplaceSubtree(4),
  )

  val directory: Map[String, Mutation] = mutations.map(m => m.name -> m).toMap
}


class MutationEngine(val activeMutations: List[Mutation]) extends LogTrait {
  def mutate(tree: Expression[?]): Expression[?] = {
    val allPossibleMutations = collectPossibleMutations(tree)

    if (allPossibleMutations.isEmpty) {
      warn("No possible mutations found")
      tree
    } else {
      val (nodeToReplace, mutationToApply, contextForNode) = allPossibleMutations(
        scala.util.Random.nextInt(allPossibleMutations.length)
      )

      info(s"Applying mutation '${mutationToApply.name}' to node '$nodeToReplace'")

      val mutatedNode = mutationToApply(nodeToReplace, contextForNode).get

      replaceNodeInTree(tree, nodeToReplace, mutatedNode)
    }
  }

  def collectPossibleMutations(
                                current: Expression[?],
                                ctx: GenerationContext = GenerationContext()
                              ): List[(Expression[?], Mutation, GenerationContext)] = {

    val mutationsForThisNode = activeMutations
      .filter(mutation => mutation(current, ctx).isDefined)
      .map(mutation => (current, mutation, ctx))

    debug(s"Mutations available for node ${current.toString}: ${mutationsForThisNode.map(_._2.name)}")

    val mutationsForChildren = current match {
      case f: ForAllExpression[?] =>
        val listType = f.iteratorDef.collection.signature.output
        val innerType = listType match {
          case ListIntType => IntType
          case _ => UnknownType
        }

        val innerCtx = ctx.withVariable(f.iteratorDef.variableName, innerType)

        collectPossibleMutations(f.iteratorDef.collection, ctx) ++
          collectPossibleMutations(f.body, innerCtx)

      case c: ComposableExpression =>
        c.children.flatMap(child => collectPossibleMutations(child, ctx))

      case _ =>
        List.empty
    }

    mutationsForThisNode ++ mutationsForChildren
  }
   def replaceNodeInTree(root: Expression[?], target: Expression[?], replacement: Expression[?]): Expression[?] = {
    if (root eq target){
      return replacement
    }

    root match {
      case c: ComposableExpression =>
        val newChildren = c.children.map(child => replaceNodeInTree(child, target, replacement))
        val childrenChanged = newChildren.zip(c.children).exists { case (newChild, oldChild) => !(newChild eq oldChild) }

        if (childrenChanged) {
          c.withNewChildren(newChildren)
        } else {
          c
        }
      case other => other
    }
  }
}

---

File: ./utils/Implicits.scala
package com.beepboop.app.utils

object Implicits {

  private object IntegerIsNumeric extends Numeric[java.lang.Integer] {
    def plus(x: java.lang.Integer, y: java.lang.Integer): java.lang.Integer = x.toInt + y.toInt
    def minus(x: java.lang.Integer, y: java.lang.Integer): java.lang.Integer = x.toInt - y.toInt
    def times(x: java.lang.Integer, y: java.lang.Integer): java.lang.Integer = x.toInt * y.toInt
    def negate(x: java.lang.Integer): java.lang.Integer = -x.toInt
    def fromInt(x: Int): java.lang.Integer = x
    def parseString(str: String): Option[java.lang.Integer] = Some(0)
    def compare(x: java.lang.Integer, y: java.lang.Integer): Int = x.compareTo(y)
    def toInt(x: java.lang.Integer): Int = x
    def toLong(x: java.lang.Integer): Long = x.toLong
    def toFloat(x: java.lang.Integer): Float = x.toFloat
    def toDouble(x: java.lang.Integer): Double = x.toDouble
  }

  implicit val integerNumeric: Numeric[java.lang.Integer] = IntegerIsNumeric

  implicit val integerOrdering: Ordering[java.lang.Integer] = IntegerIsNumeric
}

---

File: ./utils/Debugger.scala
package debugger

import com.beepboop.app.astar.ModelNodeTMP
import com.beepboop.app.dataprovider.{AStarSnapshot, PersistenceManager}

import java.awt.{BorderLayout, Dimension, FlowLayout}
import javax.swing.*
import javax.swing.tree.*
import javax.swing.table.DefaultTableModel
import java.awt.event.{ActionListener}
import java.io.*
import scala.util.{Failure, Success, Try}
import scala.reflect.ClassTag
import com.beepboop.app.dataprovider.DataProvider


object VisualDebugger {
  def launch(initialFilePath: String): Unit = {
    System.setProperty("sun.java2d.xrender", "false")
    SwingUtilities.invokeLater(() => {
      try {
        UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName)
      } catch {
        case _: Exception =>
      }
      val frame = new JFrame("A* Visual Debugger")
      frame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE)
      frame.setSize(1300, 900)
      val panel = new DebuggerPanel()
      frame.add(panel)
      if (new File(initialFilePath).exists()) panel.loadFile(initialFilePath)
      frame.setVisible(true)
    })
  }
}

class DebuggerPanel extends JPanel(new BorderLayout()) {

  private var currentSnapshot: Option[AStarSnapshot] = None
  private val objectCache = scala.collection.mutable.Map[String, Any]()
  private var currentLoadedContext = Map[String, Any]()

  private val listModel = new DefaultListModel[AnyRef]()
  private val nodeList = new JList[AnyRef](listModel)
  private val openSetRadio = new JRadioButton("Open Set", true)
  private val visitedSetRadio = new JRadioButton("Visited Set")

  private val treeRoot = new DefaultMutableTreeNode("Select a Node")
  private val treeModel = new DefaultTreeModel(treeRoot)
  private val expressionTree = new JTree(treeModel)

  private val contextTableModel = new DefaultTableModel(Array[Object]("Variable Name", "Value"), 0) {
    override def isCellEditable(row: Int, column: Int): Boolean = column == 1
  }
  private val contextTable = new JTable(contextTableModel)

  private val solutionIndexSpinner = new JSpinner(new SpinnerNumberModel(0, 0, 999999, 1))
  private val loadSolutionButton = new JButton("Load Solution Context")
  private val evalButton = new JButton("Re-Evaluate Tree")
  private val expandAllButton = new JButton("Expand All")
  private val statusLabel = new JLabel("Ready")

  initLayout()
  initListeners()

  private def initLayout(): Unit = {
    val leftPanel = new JPanel(new BorderLayout())
    val radioPanel = new JPanel(new FlowLayout(FlowLayout.LEFT))
    val group = new ButtonGroup();
    group.add(openSetRadio);
    group.add(visitedSetRadio)
    radioPanel.add(openSetRadio);
    radioPanel.add(visitedSetRadio)
    leftPanel.add(radioPanel, BorderLayout.NORTH)
    leftPanel.add(new JScrollPane(nodeList), BorderLayout.CENTER)
    leftPanel.setPreferredSize(new Dimension(350, 0))

    val treePanel = new JPanel(new BorderLayout())
    treePanel.setBorder(BorderFactory.createTitledBorder("Combined Expression Tree"))
    treePanel.add(new JScrollPane(expressionTree), BorderLayout.CENTER)

    val bottomPanel = new JPanel(new BorderLayout())
    bottomPanel.setBorder(BorderFactory.createTitledBorder("Evaluation Context"))

    val tableScroll = new JScrollPane(contextTable)
    tableScroll.setPreferredSize(new Dimension(0, 150))

    val controls = new JPanel(new FlowLayout(FlowLayout.LEFT))
    controls.add(new JLabel("Solution Index:"))
    controls.add(solutionIndexSpinner)
    controls.add(loadSolutionButton)
    controls.add(Box.createHorizontalStrut(20))
    controls.add(expandAllButton)
    controls.add(evalButton)
    controls.add(Box.createHorizontalStrut(10))
    controls.add(statusLabel)

    bottomPanel.add(tableScroll, BorderLayout.CENTER)
    bottomPanel.add(controls, BorderLayout.SOUTH)

    val rightSplit = new JSplitPane(JSplitPane.VERTICAL_SPLIT, treePanel, bottomPanel)
    rightSplit.setResizeWeight(0.7)

    add(new JSplitPane(JSplitPane.HORIZONTAL_SPLIT, leftPanel, rightSplit), BorderLayout.CENTER)
  }

  private def initListeners(): Unit = {
    val radioListener: ActionListener = _ => refreshNodeList()
    openSetRadio.addActionListener(radioListener)
    visitedSetRadio.addActionListener(radioListener)

    nodeList.addListSelectionListener(e => {
      if (!e.getValueIsAdjusting && nodeList.getSelectedValue != null) {
        extractAndShowExpression(nodeList.getSelectedValue)
      }
    })

    loadSolutionButton.addActionListener(_ => {
      val idx = solutionIndexSpinner.getValue.asInstanceOf[Int]
      loadContextFromDataProvider(idx)
    })

    evalButton.addActionListener(_ => performFullTreeEvaluation())

    expandAllButton.addActionListener(_ => expandAll(expressionTree))
  }


  private def loadContextFromDataProvider(index: Int): Unit = {
    try {
      val ctx = DataProvider.getSolutionContext(index)
      currentLoadedContext = ctx

      objectCache.clear()
      contextTableModel.setRowCount(0)

      ctx.keys.toList.sorted.foreach { key =>
        val value = ctx(key)
        objectCache.put(key, value)
        contextTableModel.addRow(Array[Object](key, value.toString))
      }

      statusLabel.setText(s"Loaded solution #$index")
      if (treeRoot.getChildCount > 0) performFullTreeEvaluation()

    } catch {
      case e: Exception =>
        JOptionPane.showMessageDialog(this, s"Failed to load solution #$index:\n${e.getMessage}")
    }
  }

  private def extractAndShowExpression(nodeWrapper: AnyRef): Unit = {
    try {
      val method = nodeWrapper.getClass.getMethod("constraint")
      val expr = method.invoke(nodeWrapper)

      treeRoot.removeAllChildren()
      treeRoot.setUserObject(new NodeWrapper("Root", expr))
      buildTreeRecursive(treeRoot, expr)
      treeModel.reload()

      expandAll(expressionTree)

      if (currentLoadedContext.nonEmpty) {
        performFullTreeEvaluation()
      } else {
        loadContextFromDataProvider(0)
      }

    } catch {
      case e: Exception => e.printStackTrace()
    }
  }

  private def buildTreeRecursive(parentUi: DefaultMutableTreeNode, obj: Any): Unit = {
    obj match {
      case p: Product =>
        p.productIterator.zip(p.productElementNames).foreach { case (child, name) =>
          if (isExpression(child)) {
            val node = new DefaultMutableTreeNode(new NodeWrapper(name, child))
            parentUi.add(node)
            buildTreeRecursive(node, child)
          } else if (child.isInstanceOf[List[_]]) {
            child.asInstanceOf[List[_]].zipWithIndex.foreach { case (item, idx) =>
              if (isExpression(item)) {
                val node = new DefaultMutableTreeNode(new NodeWrapper(s"$name[$idx]", item))
                parentUi.add(node)
                buildTreeRecursive(node, item)
              }
            }
          }
        }
      case _ =>
    }
  }


  private def performFullTreeEvaluation(): Unit = {
    val evalCtx = buildContextFromTable()
    val nodeEnum = treeRoot.breadthFirstEnumeration()

    while (nodeEnum.hasMoreElements) {
      val uiNode = nodeEnum.nextElement().asInstanceOf[DefaultMutableTreeNode]

      uiNode.getUserObject match {
        case wrapper: NodeWrapper =>
          wrapper.evalResult = try {
            val m = wrapper.obj.getClass.getMethod("eval", classOf[Map[String, Any]])
            val res = m.invoke(wrapper.obj, evalCtx)
            res match {
              case b: Boolean => if (b) "true" else "false"
              case other => other.toString
            }
          } catch {
            case _: Exception => "?"
          }

          wrapper.distResult = try {
            val m = wrapper.obj.getClass.getMethod("distance", classOf[Map[String, Any]])
            val res = m.invoke(wrapper.obj, evalCtx)
            res.toString
          } catch {
            case _: Exception => "?"
          }

        case _ =>
      }
    }

    treeModel.reload()
    statusLabel.setText("Updated Eval and Distance.")
  }

  private def buildContextFromTable(): Map[String, Any] = {
    val ctx = scala.collection.mutable.Map[String, Any]()
    for (i <- 0 until contextTableModel.getRowCount) {
      val key = contextTableModel.getValueAt(i, 0).toString
      val tableVal = contextTableModel.getValueAt(i, 1).toString.trim

      if (objectCache.contains(key) && objectCache(key).toString == tableVal) {
        ctx.put(key, objectCache(key))
      } else if (tableVal.nonEmpty) {
        val pV = if (Try(tableVal.toInt).isSuccess) tableVal.toInt
        else if (Try(tableVal.toDouble).isSuccess) tableVal.toDouble
        else if (tableVal == "true") true else if (tableVal == "false") false
        else tableVal
        ctx.put(key, pV)
      }
    }
    ctx.toMap
  }


  def loadFile(path: String): Unit = {
    PersistenceManager.loadAStarState(path) match {
      case Success(snap) =>
        currentSnapshot = Some(snap)
        refreshNodeList()
      case Failure(e) => JOptionPane.showMessageDialog(this, e.getMessage)
    }
  }

  private def refreshNodeList(): Unit = {
    listModel.clear()
    currentSnapshot.foreach { snap =>
      val items = if (openSetRadio.isSelected) snap.openSetItems else snap.visitedItems
      items.foreach(listModel.addElement)
    }
  }

  private def isExpression(o: Any): Boolean = {
    if (o == null) return false
    var c = o.getClass
    while (c != null) {
      if (c.getName.contains("Expression")) return true
      c = c.getSuperclass
    }
    false
  }

  private def expandAll(tree: JTree): Unit = {
    for (i <- 0 until tree.getRowCount) tree.expandRow(i)
    var i = 0
    while (i < tree.getRowCount) {
      tree.expandRow(i)
      i += 1
    }
  }

  class NodeWrapper(val field: String, val obj: Any) {
    var evalResult: String = "?"
    var distResult: String = "?"

    override def toString: String = {
      val typeName = obj.getClass.getSimpleName
      val content = obj.toString

      val base = s"$field: $typeName ($content)"

      if (evalResult != "?" || distResult != "?") {
        s"<html>$base <font color='blue'><b>  Eval: $evalResult | Dist: $distResult</b></font></html>"
      } else {
        base
      }
    }
  }
}

---

File: ./utils/ArgumentParser.scala
package com.beepboop.app.utils

import mainargs.{arg, ParserForClass, Flag}

// 1. Konfiguracja CLI
case class GeneratorConfig(
                            @arg(positional = true, doc = "Path to the .mzn model file")
                            modelPath: String,

                            @arg(positional = true, doc = "Path to the .json/.dzn data file")
                            dataPath: String,

                            @arg(name = "solutions", short = 's', doc = "Path to the known solutions CSV")
                            solutionsPath: Seq[String],

                            @arg(short = 'i', doc = "Maximum number of A* iterations")
                            maxIterations: Int = 50,

                            @arg(doc = "How often to save checkpoint/CSV")
                            saveInterval: Int = 100,

                            @arg(short = 'o', doc = "Output CSV file path")
                            outputCsv: String = "generated_constraints.csv",

                            @arg(short = 'c', doc = "Checkpoint file path")
                            checkpointFile: String = "astar_checkpoint.bin",

                            @arg(short = 'r', doc = "Resume from checkpoint if exists")
                            resume: Flag,

                            @arg(name = "debug", short = 'd', doc = "Launch Visual Debugger GUI instead of running search")
                            debug: Flag,

                            @arg(name = "gurobi-license", doc = "Path to gurobi license file")
                            gurobiLicense: String = ""
                          )

case class AppConfig(
                      modelPath: String,
                      dataPath: String,
                      solutionsPath: Option[String],
                      maxIterations: Int,
                      saveInterval: Int,
                      outputCsv: String,
                      checkpointFile: String,
                      resume: Boolean,
                      debug: Boolean,
                      gurobiLicense: String
                    )

object ArgumentParser {

  private val parser = ParserForClass[GeneratorConfig]

  private val HelpHeader =
    """
      |AStar Model Generator v1.0
      |Generates MiniZinc constraints using A* search algorithm based on provided data.
      |
      |Usage: sbt "run <modelPath> <dataPath> [options]"
      |""".stripMargin

  private val HelpFooter =
    """
      |EXAMPLES:
      |  Basic run:
      |    sbt "run models/accap.mzn models/accap.json -s models/sols.csv"
      |
      |  Resume:
      |    sbt "run models/accap.mzn models/accap.json -s models/sols.csv -r"
      |""".stripMargin

  def parse(args: Array[String]): Option[AppConfig] = {

    if (args.contains("--help") || args.contains("-h")) {

      val rawLibraryHelp = parser.helpText(customName = "astar-generator")

      val optionsList = rawLibraryHelp.linesIterator.drop(1).mkString("\n")

      println(HelpHeader)
      println("Options:")
      println(optionsList)
      println(HelpFooter)

      return None
    }

    parser.constructEither(args.toSeq) match {
      case Right(cli) =>
        Some(AppConfig(
          modelPath = cli.modelPath,
          dataPath = cli.dataPath,
          solutionsPath = cli.solutionsPath.headOption,
          maxIterations = cli.maxIterations,
          saveInterval = cli.saveInterval,
          outputCsv = cli.outputCsv,
          checkpointFile = cli.checkpointFile,
          resume = cli.resume.value,
          debug = cli.debug.value,
          gurobiLicense = cli.gurobiLicense
        ))

      case Left(errorMsg) =>
        println(s"Error parsing arguments: $errorMsg")
        println("\nRun with --help to see usage.")
        None
    }
  }
}

---

File: ./policy/Base.scala
package com.beepboop.app.policy

import com.beepboop.app.components.{BinaryExpression, ComposableExpression, Constant, DivOperator, Expression, Variable}

sealed trait PolicyResult {
  def isAllowed: Boolean
  def &&(other: PolicyResult): PolicyResult = if (isAllowed) other else this
  def ||(other: PolicyResult): PolicyResult = if (isAllowed) this else other
}
case object Compliant extends PolicyResult {val isAllowed = true }
case class NonCompliant(expr: Expression[?], message: String) extends PolicyResult { val isAllowed = false }

sealed trait Policy {
  def message = "Expression doesn't match policy"
}

trait LocalPolicy extends Policy {
  def validate(node: Expression[?]): PolicyResult
}

trait GlobalPolicy extends Policy {
  def reset(): Unit
  def visit(node: Expression[?]): Unit
  def isSatisfied: Boolean
  def cloneForBranch(): GlobalPolicy = this
}


case class EnsureAnyVarExists() extends GlobalPolicy {
  private var found = false

  override def message: String = "Expression must contain at least one variable"

  override def reset(): Unit = {
    found = false
  }

  override def visit(node: Expression[?]): Unit = {
    if (!found) {
      node match {
        case _: Variable[?] => found = true
        case _ =>
      }
    }
  }

  override def isSatisfied: Boolean = found
}


case class EnsureSpecificVarExists(targetName: String) extends GlobalPolicy {
  private var found = false

  override def message: String = s"Expr doesn't contain '$targetName' in scope"

  override def reset(): Unit = {
    found = false
  }

  override def visit(node: Expression[?]): Unit = {
    if (!found) {
      node match {
        case v: Variable[?] if v.name == targetName =>
          found = true
        case _ =>
      }
    }
  }


  override def isSatisfied: Boolean = found
}

case class DenyDivByZero() extends LocalPolicy {

  override def message: String = s"Division by 0 is not allowed"

  override def validate(node: Expression[_]): PolicyResult = node match {
    case BinaryExpression(_, operator, rightChild) =>
      val isDivision = operator.isInstanceOf[DivOperator[?]]

      if (isDivision) {
        rightChild match {
          case Constant(0) => NonCompliant(node, message)
          case _ => Compliant
        }
      }  else {
        Compliant
      }
    case _ => Compliant
  }
}


---

File: ./policy/Scanner.scala
package com.beepboop.app.policy

import com.beepboop.app.components.{ComposableExpression, Expression, ScopeModifier}
import com.beepboop.app.logger.LogTrait



object Scanner extends LogTrait {
  val DefaultSuccess = Compliant

  def visitAll(root: Expression[?], policies: Policy*): PolicyResult = {
    val locals = policies.collect { case p: LocalPolicy => p }.toList
    val globals = policies.collect { case p: GlobalPolicy => p }.toList

    globals.foreach(_.reset())

    val result = visitRecursive(root, locals, globals)

    if (!result.isAllowed) return result

    val globalResult = globals.foldLeft[PolicyResult](DefaultSuccess) { (res, policy) =>
      if (policy.isSatisfied) res else NonCompliant(root, policy.message)
    }

    globalResult
  }

  private def visitRecursive(
                              node: Expression[?],
                              locals: List[LocalPolicy],
                              globals: List[GlobalPolicy]
                            ): PolicyResult = {

    globals.foreach(_.visit(node))

    val localRes = locals.foldLeft[PolicyResult](DefaultSuccess)(_ && _.validate(node))
    if (!localRes.isAllowed) return localRes

    val (newLocals, newGlobals) = node match {
      case m: ScopeModifier =>
        val extras = m.getAdditionalPolicies
        (extras.collect { case p: LocalPolicy => p }, extras.collect { case p: GlobalPolicy => p })
      case _ =>
        (Nil, Nil)
    }

    val currLocals = locals ++ newLocals
    val currGlobals = globals ++ newGlobals


    node match {
      case c: ComposableExpression =>
        val childrenRes = c.children.map(child => visitRecursive(child, currLocals, currGlobals))
          .foldLeft[PolicyResult](DefaultSuccess)(_ && _)

        if (!childrenRes.isAllowed) return childrenRes

        newGlobals.foldLeft[PolicyResult](childrenRes) { (res, pol) =>
          if (pol.isSatisfied) res else NonCompliant(node, pol.message)
        }

      case _ => Compliant
    }
  }
}

---

File: ./postprocessor/Postprocessor.scala
package com.beepboop.app.postprocessor

import com.beepboop.app.components.*
import com.beepboop.app.logger.LogTrait

import scala.annotation.tailrec
import scala.reflect.{ClassTag, classTag}

sealed trait Rule {
  def condition[T : ClassTag]: (Expression[T] => Boolean)
  def action[T : ClassTag]: (Expression[T] => Expression[T])

}

case class JoinConstants() extends Rule, LogTrait {
  def condition[T : ClassTag]: (Expression[T] => Boolean) = {
    case c: ComposableExpression =>
      val childrenAreConstants = c.children.forall(child => child.isInstanceOf[Constant[?]])

      val isStructuralNode = c.isInstanceOf[IteratorDef[?]]
      childrenAreConstants && !isStructuralNode
    case _ => false
  }

  def action[T : ClassTag]: (Expression[T] => Constant[T]) = {
    case c: ComposableExpression => {
      val resultValue = c.eval(context = Map.empty)
      debug(s"Eval of ${c} is ${resultValue} type [${resultValue.getClass.getSimpleName}] expected [${classTag[T].runtimeClass.getSimpleName}]")
      Constant[T](resultValue)
    }
  }

}

case class SimplifyConstantForall() extends Rule {
  def condition[T: ClassTag]: (Expression[T] => Boolean) = {
    case c: ForAllExpression[T] =>
      val bodyIsConstant = c.body.isInstanceOf[Constant[Boolean]]
      bodyIsConstant
    case _ => false
  }

  def action[T: ClassTag]: (Expression[T] => Constant[T]) = {
    case c: ForAllExpression[T] => {
      val resultValue = c.body.eval(context = Map.empty)
      Constant[T](resultValue)
    }
  }
}

case class RemoveRedundantTrueAnd() extends Rule {
  def condition[T: ClassTag]: (Expression[T] => Boolean) = {
    case b: BinaryExpression[T] =>
      val operatorIsAnd = b.operator.isInstanceOf[AndOperator[?]]
      val oneIsTrue = b.children.exists(c =>
        c match {
          case const: Constant[?] =>
            const.eval(Map.empty) match {
              case true => true
              case _ => false
            }
          case _ => false

        }
      )
      operatorIsAnd && oneIsTrue
    case _ => false
  }

  def action[T: ClassTag]: (Expression[T] => Expression[T]) = {
    case b: BinaryExpression[T] => {
      val nonConstant = b.children.filterNot(c => c.isInstanceOf[Constant[Boolean]]).head
      nonConstant.asInstanceOf[Expression[T]]
    }
  }
}


case class RemoveRedundantFalseAnd() extends Rule {
  def condition[T: ClassTag]: (Expression[T] => Boolean) = {
    case b: BinaryExpression[T] =>
      val operatorIsAnd = b.operator.isInstanceOf[AndOperator[?]]
      val oneIsTrue = b.children.exists(c =>
        c match {
          case const: Constant[?] =>
            const.eval(Map.empty) match {
              case false => true
              case _ => false
            }
          case _ => false

        }
      )
      operatorIsAnd && oneIsTrue
    case _ => false
  }

  def action[T: ClassTag]: (Expression[T] => Expression[T]) = {
    case b: BinaryExpression[T] => {
      Constant[T](false.asInstanceOf[T])
    }
  }
}


case class RemoveRedundantTrueOr() extends Rule {
  def condition[T: ClassTag]: (Expression[T] => Boolean) = {
    case b: BinaryExpression[T] =>
      val operatorIsOr = b.operator.isInstanceOf[OrOperator[?]]
      val oneIsTrue = b.children.exists(c =>
        c match {
          case const: Constant[?] =>
            const.eval(Map.empty) match {
              case true => true
              case _ => false
            }
          case _ => false

        }
      )
      operatorIsOr && oneIsTrue
    case _ => false
  }

  def action[T: ClassTag]: (Expression[T] => Constant[T]) = {
    case b: BinaryExpression[T] => {
      Constant[T](true.asInstanceOf[T])
    }
  }
}

case class RemoveRedundantFalseOr() extends Rule {
  def condition[T: ClassTag]: (Expression[T] => Boolean) = {
    case b: BinaryExpression[T] =>
      val operatorIsOr = b.operator.isInstanceOf[OrOperator[?]]
      val oneIsTrue = b.children.exists(c =>
        c match {
          case const: Constant[?] =>
            const.eval(Map.empty) match {
              case false => true
              case _ => false
            }
          case _ => false

        }
      )
      operatorIsOr && oneIsTrue
    case _ => false
  }

  def action[T: ClassTag]: (Expression[T] => Expression[T]) = {
    case b: BinaryExpression[T] => {
      val nonConstant = b.children.filterNot(c => c.isInstanceOf[Constant[Boolean]]).head
      nonConstant.asInstanceOf[Expression[T]]
    }
  }
}

case class RemoveUnnecessaryAdd() extends Rule {
  override def condition[T: ClassTag]: Expression[T] => Boolean = {
    case b: BinaryExpression[T] =>
      val operatorIsAdd = b.operator.isInstanceOf[AddOperator[?]]
      val zeroExists = b.children.exists(c =>
        c match {
          case const: Constant[?] =>
            const eval(Map.empty) match {
              case 0 => true
              case _ => false
            }
          case _ => false
        }
      )
      operatorIsAdd && zeroExists
    case _ => false
  }

  override def action[T: ClassTag]: Expression[T] => Expression[T] = {
    case b: BinaryExpression[T] => {
      val nonConst = b.children.filterNot(c => c.isInstanceOf[Constant[?]]).head
      nonConst.asInstanceOf[Expression[T]]
    }
  }
}


case class RemoveUnnecessarySub() extends Rule {
  override def condition[T: ClassTag]: Expression[T] => Boolean = {
    case b: BinaryExpression[T] =>
      val operatorIsSub = b.operator.isInstanceOf[SubOperator[?]]
      val zeroExists = b.children.exists(c =>
        c match {
          case const: Constant[?] =>
            const eval(Map.empty) match {
              case 0 => true
              case _ => false
            }
          case _ => false
        }
      )
      operatorIsSub && zeroExists
    case _ => false
  }

  override def action[T: ClassTag]: Expression[T] => Expression[T] = {
    case b: BinaryExpression[T] => {
      val child1 = b.children.head
      val child2 = b.children.tail.head

      if (child1.isInstanceOf[Constant[?]]) {
        val op = classTag[T].runtimeClass match {
          case c if  c == classOf[Integer] => NegateOperator[Integer]()
          /* v based on the assumptions this shouldn't happen */
          case _ => throw Exception("RemoveUnnecessarySub failed to assume Integer, thus attempted to create NegateOperator with unknown type")
        }
        UnaryExpression[T](
          child2.asInstanceOf[Expression[T]],
          op.asInstanceOf[UnaryOperator[T]]
        )
      } else {
        child1.asInstanceOf[Expression[T]]
      }
    }
  }
}

case class RemoveUnnecessaryMult() extends Rule {
  override def condition[T: ClassTag]: Expression[T] => Boolean = {
    case b: BinaryExpression[T] =>
      val operatorIsMul = b.operator.isInstanceOf[MulOperator[?]]
      val OneOrZero = b.children.exists(c =>
        c match {
          case const: Constant[?] =>
            const.eval(Map.empty) match {
              case 0 => true
              case 1 => true
              case _ => false
            }
          case _ => false
        }
      )
      operatorIsMul && OneOrZero
    case _ => false
  }

  override def action[T: ClassTag]: Expression[T] => Expression[T] = {
    case b: BinaryExpression[T] => {
      val const = b.children.filter(c => c.isInstanceOf[Constant[?]]).head
      val nonConst = b.children.filterNot(c => c.isInstanceOf[Constant[?]]).head

      const.eval(Map.empty) match {
        case 0 => Constant[T](0.asInstanceOf[T])
        case 1 => nonConst.asInstanceOf[Expression[T]]
      }
    }
  }
}


case class VarDivToOne() extends Rule {
  override def condition[T: ClassTag]: Expression[T] => Boolean = {
    case b: BinaryExpression[T] =>
      val operatorIsDiv = b.operator.isInstanceOf[DivOperator[?]]

      val AllAreVarsAndSameName = b.children.headOption match {
        case Some(first: Variable[?]) =>
          b.children.forall {
            case v: Variable[?] => v.name == first.name
            case _              => false
          }
        case None => true
        case _    => false
      }
      operatorIsDiv && AllAreVarsAndSameName
    case _ => false
  }

  override def action[T: ClassTag]: Expression[T] => Expression[T] = {
    case b: BinaryExpression[T] => {
      Constant[T](1.asInstanceOf[T])
    }
  }
}


case class VarDivToN() extends Rule {
  override def condition[T: ClassTag]: Expression[T] => Boolean = {
    case b: BinaryExpression[T] if b.operator.isInstanceOf[DivOperator[?]] =>
      b.children match {
        case List(numerator: BinaryExpression[?], denominator: Variable[?])
          if numerator.operator.isInstanceOf[MulOperator[?]] =>

          numerator.children match {
            case List(c: Constant[?], v: Variable[?]) =>
              v.name == denominator.name
            case List(v: Variable[?], c: Constant[?]) =>
              v.name == denominator.name
            case _ => false
          }
        case _ => false
      }
    case _ => false
  }

  override def action[T: ClassTag]: Expression[T] => Expression[T] = {
    case b: BinaryExpression[T] =>
      val numerator = b.children.head.asInstanceOf[BinaryExpression[T]]

      numerator.children.find(_.isInstanceOf[Constant[?]]) match {
        case Some(constExpr) => constExpr.asInstanceOf[Expression[T]]
        case None => b
      }
  }
}

case class SubVarsToZero() extends Rule {
  override def condition[T: ClassTag]: Expression[T] => Boolean = {
    case b: BinaryExpression[T] =>
      val operatorIsSub = b.operator.isInstanceOf[SubOperator[?]]
      val AllAreVarsAndSameName = b.children.headOption match {
        case Some(first: Variable[?]) =>
          b.children.forall {
            case v: Variable[?] => v.name == first.name
            case _ => false
          }
        case None => true
        case _ => false
      }

      operatorIsSub && AllAreVarsAndSameName
    case _ => false
  }

  override def action[T: ClassTag]: Expression[T] => Expression[T] = {
    case b: BinaryExpression[T] =>
      Constant[T](0.asInstanceOf[T])
  }

}


case class EqualityToTrue() extends Rule {
  override def condition[T: ClassTag]: Expression[T] => Boolean = {
    case b: BinaryExpression[T] =>
      val operatorIsEquatable = b.operator.isInstanceOf[EqualOperator[?]] ||
          b.operator.isInstanceOf[LessEqualOperator[?]] ||
          b.operator.isInstanceOf[GreaterEqualOperator[?]]

      val AllAreVarsAndSameName = b.children.headOption match {
        case Some(first: Variable[?]) =>
          b.children.forall {
            case v: Variable[?] => v.name == first.name
            case _ => false
          }
        case None => true
        case _ => false
      }

      operatorIsEquatable && AllAreVarsAndSameName
    case _ => false
  }

  override def action[T: ClassTag]: Expression[T] => Expression[T] = {
    case b: BinaryExpression[T] =>
      Constant[T](true.asInstanceOf[T])
  }

}


case class NotEqualityToFalse() extends Rule {
  override def condition[T: ClassTag]: Expression[T] => Boolean = {
    case b: BinaryExpression[T] =>
      val operatorIsEquatable = b.operator.isInstanceOf[NotEqualOperator[?]] ||
        b.operator.isInstanceOf[LessOperator[?]] ||
        b.operator.isInstanceOf[GreaterOperator[?]]

      val AllAreVarsAndSameName = b.children.headOption match {
        case Some(first: Variable[?]) =>
          b.children.forall {
            case v: Variable[?] => v.name == first.name
            case _ => false
          }
        case None => true
        case _ => false
      }

      operatorIsEquatable && AllAreVarsAndSameName
    case _ => false
  }

  override def action[T: ClassTag]: Expression[T] => Expression[T] = {
    case b: BinaryExpression[T] =>
      Constant[T](false.asInstanceOf[T])
  }

}


object Postprocessor {
  private def availableRules = LazyList (
    JoinConstants(),
    SimplifyConstantForall(),
    RemoveRedundantTrueOr(),
    RemoveRedundantFalseOr(),
    RemoveRedundantFalseAnd(),
    RemoveRedundantTrueAnd(),
    RemoveUnnecessaryMult(),
    RemoveUnnecessaryAdd(),
    RemoveUnnecessarySub(),
    VarDivToOne(),
    VarDivToN(),
    SubVarsToZero(),
    EqualityToTrue(),
    NotEqualityToFalse()
  )
  @tailrec
  private def applyAllRules[T : ClassTag](expr: Expression[T]): Expression[T] = {
    val distinctResult = availableRules.foldLeft(expr) { (curr, rule) =>
      if (rule.condition(curr)) rule.action(curr).asInstanceOf[Expression[T]] else curr
    }

    if (distinctResult != expr) applyAllRules(distinctResult) else expr
  }

  def simplify[T : ClassTag](expr: Expression[T]): Expression[T] = {
    val nodeWithSimplifiedChildren: Expression[T] = expr match {
      case c: ComposableExpression =>
        val newChildren = c.children.map {
          case childTyped: Expression[childT] =>
            implicit val childTag: ClassTag[childT] = childTyped.ct
            simplify(childTyped)
        }
        c.withNewChildren(newChildren).asInstanceOf[Expression[T]]
      case leaf =>
        leaf
    }
    Postprocessor.applyAllRules(nodeWithSimplifiedChildren)
  }
}

---

File: ./cpicker/ConstraintPicker.scala
package com.beepboop.app.cpicker

import com.beepboop.app.astar.ModelNodeTMP
import com.beepboop.app.components.Expression
import com.beepboop.app.dataprovider.PersistenceManager
import com.beepboop.app.logger.{LogTrait, Profiler}
import com.beepboop.app.utils.AppConfig

import scala.collection.parallel.CollectionConverters.*
import scala.collection.mutable

case class ConstraintData(constraint: List[Expression[?]], heuristics: Double, solCount: Long)

object ExpressionOrdering extends Ordering[Expression[?]] {
  def compare(x: Expression[?], y: Expression[?]): Int = x.toString.compareTo(y.toString)
}

object ConstraintPicker extends LogTrait {
  var config: AppConfig = null

  def setConfig(config: AppConfig): Unit = {
    this.config = config
  }

  private def order(item: ConstraintData) = -item.solCount

  var queue: mutable.PriorityQueue[ConstraintData] = mutable.PriorityQueue[ConstraintData]()(Ordering.by(order))

  def runInitial(nodes: mutable.Set[ModelNodeTMP], maxRounds: Int = 3, keepRatio: Double = 0.5, threshold: Int = 500): Unit = {
    val initialWorkload = nodes.par
    val validSingles = new mutable.ListBuffer[Expression[?]]()
    val round1Results = new mutable.ListBuffer[ConstraintData]()
    info("Starting single evaluation using minizinc")
    initialWorkload.foreach { tmpNode =>
      val expr = tmpNode.constraint
      val tmpFile = ConstraintSaver.save(expr)
      val runner = new Runner(this.config)
      val solCount = runner.run(tmpFile)
      solCount match {
        case Some(value) if (value >= threshold) => {
          val data = ConstraintData(List(expr), tmpNode.f, value)
          queue.synchronized {
            queue.enqueue(data)
          }
          validSingles.synchronized {
            validSingles += expr
          }
          round1Results.synchronized {
            round1Results += data
          }
        }
        case Some(value) => Profiler.recordValue("Discarded by threshold", 1)
        case None =>
      }
    }
    info(s"ValidSingles: ${validSingles.size}")

    val baseExpressions = validSingles.toList
    var currentRoundGroups = round1Results
      .sortBy(_.solCount)
      .take((round1Results.size * keepRatio).toInt.max(1))
      .map(_.constraint)
      .toList

    for (round <- 2 to maxRounds) {
      info(s"Starting round $round with ${currentRoundGroups.size} groups")
      if (currentRoundGroups.nonEmpty) {
        val candidates = currentRoundGroups.flatMap { group =>
          baseExpressions.map { single =>
            if (group.contains(single)) group else (single :: group).sorted(ExpressionOrdering)
          }
        }.toSet.filter(_.size == round)

        val roundResults = new mutable.ListBuffer[ConstraintData]()
        val batchWorkload = candidates.toList.par

        batchWorkload.foreach { group =>
          val tmpFile = ConstraintSaver.save(group: _*)
          val runner = new Runner(this.config)
          val solCount = runner.run(tmpFile)
          solCount match {
            case Some(value) if (value >= threshold) => {
              val data = ConstraintData(group, 0.0, value)
              queue.synchronized {
                queue.enqueue(data)
              }
              roundResults.synchronized {
                roundResults += data
              }
            }
            case Some(value) => Profiler.recordValue("Discarded by threshold", 1)
            case None =>
          }
        }

        currentRoundGroups = roundResults
          .sortBy(_.solCount)
          .take((roundResults.size * Math.pow(keepRatio, round)).toInt.max(1))
          .map(_.constraint)
          .toList
        info(s"CurrentRoundGroups count ${currentRoundGroups.size}")
      }
    }

    PersistenceManager.saveConstraintsToCSV(queue.clone().dequeueAll, "queue.csv")
  }
}

---

File: ./cpicker/ConstraintSaver.scala
package com.beepboop.app.cpicker

import com.beepboop.app.components.*
import com.beepboop.app.utils.AppConfig

import java.nio.charset.StandardCharsets
import java.nio.file.{Files, Path, StandardOpenOption}
import java.io.File


object ConstraintSaver {
  var config: AppConfig = null

  def setConfig(config: AppConfig): Unit = {
    this.config = config
  }
  def save(constraints: Expression[?]*): Path = {
    val tempPath: Path = Files.createTempFile("mzn_temp_", ".mzn")
    tempPath.toFile.deleteOnExit();

    val content = new StringBuilder()

    content.append(s"include \"${config.modelPath}\";\n")
    content.append(s"include \"alldifferent.mzn\";\n\n")
    constraints.foreach { c =>
      content.append(s"constraint ${c.toString};\n")
    }
    Files.write(
      tempPath,
      content.toString().getBytes(StandardCharsets.UTF_8),
      StandardOpenOption.CREATE,
      StandardOpenOption.WRITE,
      StandardOpenOption.TRUNCATE_EXISTING,
      StandardOpenOption.SYNC
    )
    tempPath
  }

}


---

File: ./cpicker/Runner.scala
package com.beepboop.app.cpicker

import com.beepboop.app.utils.AppConfig

import java.io.File
import java.nio.file.Path
import scala.sys.process.*
import spray.json.*
import DefaultJsonProtocol.*
import com.beepboop.app.logger.{LogTrait, Profiler}

class Runner(config: AppConfig) extends LogTrait {
  def run(path: Path): Option[Long] = {
    val currentWorkingDir = System.getProperty("user.dir")

    val command = Seq(
      "minizinc",
      "--solver", "gurobi",
      "-I", currentWorkingDir,
      "--json-stream",
      "--param-file-no-push", "config.mpc",
      "--parallel", "1",
      "--all-solutions",
      path.toAbsolutePath.toString,
      config.dataPath
    )
    debug(s"Running: ${command.mkString(" ")}")

    val stdout = new StringBuilder
    val stderr = new StringBuilder
    val logger = ProcessLogger(stdout append _, stderr append _)
    val status = Process(command, new File("."), "GRB_LICENSE_FILE" -> config.gurobiLicense) ! logger

    if (status == 0) {
      val parsedOutput = stdout.toString().replace("}{", "}\n{").split("\n")
      debug(s"Output head: ${parsedOutput.head}")
      val jsonObjects = parsedOutput.map(o => o.parseJson.asJsObject)

      val count = jsonObjects.count(j => j.fields.get("output") match {
        case Some(jsValue) => true
        case None =>  {
          Profiler.recordValue("Invalid mzn", 1)
          false
        }
      })
      Some(count)
    } else {
      debug(stdout.toString)
      debug(stderr.toString)
      None
    }
  }
}

---

